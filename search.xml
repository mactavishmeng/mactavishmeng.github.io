<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Brida 不完全折腾手册</title>
    <url>/2020/03/31/Python3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Brida%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>最近在测试 Android APP 的时候，发现目标程序做了HTTPS证书校验，而因为 APK 混淆过，因此<code>xposed</code>插件（比如<code>SSL Unpinning</code>或者<code>Just Trust Me</code>）就失效了，因为要hook的函数名被修改了。因此想到用<code>Frida</code>来进行动态查看和Hook。</p>
<a id="more"></a>

<blockquote>Brida是一款Burp Suite扩展，作为一座桥梁连接着Burp Suite以及Frida，以帮助用户修改应用程序与后端服务器之间的通信数据为己任。</blockquote>
关于`Brida`，Freebuf上已有介绍，不再赘述，感兴趣的可以看[这里](https://www.freebuf.com/sectool/143360.html)。但是，官方的`Brida`发布于2018年，原生支持的是`python 2.7`，或者说只在`py27`环境下测试过，而`Frida`版本迭代之快，在如今的环境下已经无法再适应`py2.7`的环境了。

<p>尝试在<code>python3</code>环境下安装的时候，发现并不能使用，因此才有了本文折腾的全过程，看了无数遍官方文档，慢慢领会了其中的精髓，现在记录下来，与大家分享。</p>
<p>可以说安装的过程中每一步都是坑，接下来慢慢分享~</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>第一个坑：<code>Python</code>环境。</p>
<p>在安装<code>Frida</code>的时候，对于<code>Python</code>的版本还是有一定要求的。</p>
<h3 id="确定版本"><a href="#确定版本" class="headerlink" title="确定版本"></a>确定版本</h3><p><strong>Step 1: 确定<code>Frida</code>版本</strong></p>
<p>这一步需要你定下来要用的<code>Frida</code>是哪个版本，因为这与整个环境都有着巨大的关系。访问Github的<a href="https://github.com/frida/frida/releases">下载页面</a>，下载<code>frida-server-xx.xx.xx-android-xx.tar.gz</code>并在你的机器上（模拟器或者手机均可）运行。</p>
<p><strong>Step2: 确定支持的<code>Python</code>版本</strong></p>
<p><em>不同版本的<code>Frida</code>支持的Python版本是不一样的。</em>把能用的<code>Frida</code>版本记下来，比如<code>12.8.17</code>，此时访问<code>Pypi</code>的Frida下载页，如果你的<code>pip</code>用了国内源，就去访问该源的页面，比如我用的清华大学的源，那就访问<a href="https://pypi.tuna.tsinghua.edu.cn/simple/frida/%E3%80%82">https://pypi.tuna.tsinghua.edu.cn/simple/frida/。</a></p>
<p><img src="/2020/03/31/Python3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Brida%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/image-20200331115856690.png" alt="image-20200331115856690"></p>
<p>在这个列表中找到相应的版本<code>12.8.17</code>，并查看文件名。比如：</p>
<p><img src="/2020/03/31/Python3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Brida%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/image-20200331120051557.png" alt="image-20200331120051557"></p>
<p>比如你是在Windows 64位平台使用，就下载<code>frida-12.8.17-py3.7-win-amd64.egg</code>，Linux平台就下载相应的egg即可。</p>
<h3 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h3><p>根据上面查看到的<code>egg</code>文件前标示的<code>Python</code>版本，选择安装。</p>
<h4 id="Linux系统（基于pyenv）"><a href="#Linux系统（基于pyenv）" class="headerlink" title="Linux系统（基于pyenv）"></a>Linux系统（基于<code>pyenv</code>）</h4><ul>
<li><strong>安装<code>pyenv</code></strong></li>
</ul>
<p>如果选择在Linux系统下使用<code>Brida</code>，比如在<code>Kali</code>里使用，推荐使用<code>pyenv</code>进行python环境的版本管理，非常的方便，安装方法参见<a href="https://github.com/pyenv/pyenv#basic-github-checkout">pyenv的官方Github</a>。</p>
<ul>
<li><strong>安装<code>Python</code></strong></li>
</ul>
<p>安装Python的时候会踩几个坑：</p>
<ol>
<li><p>依赖库</p>
<p><code>pyenv</code>在安装Python时会从其源码进行编译，因此需要有依赖库的支持，否则即使不报错的安装完，在运行的时候也会有问题。以<code>Kali</code>为例（<code>Ubuntu</code>、<code>Debian</code>命令应该是一样的，其他的Linux系统原理类似），需要安装的库可能有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libbz2-dev</span><br><span class="line">librealine-dev</span><br><span class="line">zlib1g-dev</span><br><span class="line">libffi-dev</span><br><span class="line">libsqlite3-dev</span><br><span class="line">liblzma-dev</span><br></pre></td></tr></table></figure>

<p>以上库是我在安装的过程中报错信息里提示的，比如<code>ModuleNotFoundError: No module named &#39;_sqlite3&#39;</code></p>
</li>
<li><p>下载安装</p>
<p>在使用命令<code>pyenv install 3.6.5</code>来安装<code>Python 3.6.5</code>时，会有如下显示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pentest@DESKTOP<span class="literal">-2AE07FJ</span>:~<span class="variable">$</span> pyenv install <span class="number">3.6</span>.<span class="number">5</span></span><br><span class="line">Downloading Python<span class="literal">-3</span>.<span class="number">6.5</span>.tar.xz...</span><br><span class="line">-&gt; https://www.python.org/ftp/python/<span class="number">3.6</span>.<span class="number">5</span>/Python<span class="literal">-3</span>.<span class="number">6.5</span>.tar.xz</span><br></pre></td></tr></table></figure>

<p>pyenv会去尝试下载<code>tar.gz</code>格式的源码来进行编译，一般情况下国内网络会非常缓慢，让pyenv自己去下载会下到天荒地老，而且还有可能等了半小时之后给你弹一个error，非常讨厌。</p>
<p>这时候可以拿着这个链接手动下载（Linux上可以安装<code>aria2</code>，使用方法百度很多）。</p>
<p>下载完毕后，在<code>~/.pyenv/</code>路径下新建文件夹<code>cache</code>，并把下载好的<code>tar.xz</code>文件放进去，再运行<code>pyenv install 3.6.5</code>，就会跳过下载直接开始编译安装。</p>
</li>
</ol>
<p>安装完毕后，使用<code>pyenv versions</code>查看，如果能看到列表，说明安装成功。使用命令<code>pyenv global 3.6.5</code>即可全局切换到<code>Python 3.6.5</code>环境下。</p>
<ul>
<li><strong>安装<code>pyenv-virtualenv</code></strong></li>
</ul>
<p>此时就可以安装<code>Frida</code>了，但是推荐安装<code>pyenv</code>的插件<code>virtualenv</code>，避免因为依赖组件版本冲突导致工具不能安装的问题。<code>virtualenv</code>的安装参见<a href="https://github.com/pyenv/pyenv-virtualenv#installation">官方Github</a>。</p>
<p>安装完毕后，使用命令<code>pyenv virtualenv 3.6.5 frida</code>来创建一个基于<code>Python 3.6.5</code>版本的、名为<code>frida</code>的虚拟环境，并使用<code>pyenv activate frida</code>来启用它。</p>
<p>启用成功后，命令行开头会显示一个括号：</p>
<p><img src="/2020/03/31/Python3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Brida%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/image-20200331142403386.png" alt="image-20200331142403386"></p>
<h4 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h4><p>Windows环境下，因为<code>pyenv-win</code>支持不好，因此直接安装即可：直接去官网下载对应版本的<code>.msi</code>的安装包，双击安装。要注意的是，在安装时<strong>不要勾选</strong>“Add Python 3.x to PATH”的选项，以免对当前系统中的环境造成影响。</p>
<p><img src="/2020/03/31/Python3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Brida%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/image-20200331143420055.png" alt="image-20200331143420055"></p>
<p>由于不加入PATH，所以相对来说环境是独立的，也算是比较方便好用了。</p>
<p>记住Python的安装路径，后面需要用到。</p>
<h3 id="安装Frida、Frida-tools和Pyro4"><a href="#安装Frida、Frida-tools和Pyro4" class="headerlink" title="安装Frida、Frida-tools和Pyro4"></a>安装Frida、Frida-tools和Pyro4</h3><p>Python环境安装完毕，可以开始安装Frida了。此时需要准备阶段下载的<code>frida-12.8.17-py3.7-xxx-xxx.egg</code>文件。</p>
<p>理论上来说可以使用pip命令<code>pip install frida==12.8.17</code>来进行安装，但是可能会卡在<code>Running setup.py install for frida ... -</code>不动，因此需要<code>.egg</code>文件直接安装。</p>
<p><code>Pyro4</code>是<code>Brida</code>与<code>Frida</code>通信的中间件，需要一并安装。</p>
<h4 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h4><p>在使用virtualenv切换环境后，直接输入<code>easy_install ~/Downloads/frida-12.8.17-py3.6-linux-x86_64.egg</code>即可。</p>
<p>使用命令<code>pip install frida-tools</code>安装<code>frida-tools</code>。</p>
<p>使用命令<code>pip install pyro4</code>安装<code>Pyro4</code>。</p>
<p><img src="/2020/03/31/Python3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Brida%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/image-20200331150103543.png" alt="image-20200331150103543"></p>
<h4 id="Windows环境-1"><a href="#Windows环境-1" class="headerlink" title="Windows环境"></a>Windows环境</h4><p>Windows环境下需要进入安装步骤中的安装路径，如<code>C:\Users\[用户名]\AppData\Local\Programs\Python\Python37</code>，在此处打开命令行，输入命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\Users\xx\AppData\Local\Programs\Python\Python37&gt;.\Scripts\easy_install.exe C:\Users\xx\Downloads\frida<span class="literal">-12</span>.<span class="number">8.17</span><span class="literal">-py3</span>.<span class="number">7</span><span class="literal">-win</span><span class="literal">-amd64</span>.egg</span><br></pre></td></tr></table></figure>

<p>安装Frida。安装成功后，输入<code>.\Scripts\pip.exe install frida-tools</code>来安装Frida-tools。</p>
<p>输入<code>.\Scripts\pip.exe install pyro4</code>安装<code>Pyro4</code>。</p>
<p>至此，<code>Frida</code>和<code>Frida-tools</code>均安装完毕。</p>
<h3 id="配置Brida"><a href="#配置Brida" class="headerlink" title="配置Brida"></a>配置Brida</h3><p><code>Brida</code>需要<code>Burpsuite</code>支持，Community版本和Pro均可。安装方法很简单，可以直接在<code>BApp Store</code>中安装，也可以进入<a href="https://github.com/federicodotta/Brida/releases">Brida的Releases页面</a>下载（推荐去官网下载，因为后面要修改这个<code>jar</code>）</p>
<h4 id="适配Python3"><a href="#适配Python3" class="headerlink" title="适配Python3"></a>适配Python3</h4><p><strong>大坑预警！大坑预警！大坑预警！</strong>重要的事情说三遍！</p>
<p>由于<code>Brida</code>编写的时候支持<code>Python2.7</code>，因此在<code>3.6</code> / <code>3.7</code>的环境下无法直接运行。2019年5月就有人在issues中提出<a href="https://github.com/federicodotta/Brida/issues/39">这个问题</a>，作者在2020年3月才进行了回答，并给出了一个解决方案：修改插件中的<code>.py</code>文件，方法如下：</p>
<ol>
<li><p>找到插件<code>Brida_xxx.jar</code>文件。插件的根目录：</p>
<ul>
<li>Windows：<code>C:\Users\xx\AppData\Roaming\BurpSuite</code></li>
<li>Linux：<code>~/.BurpSuite</code></li>
</ul>
<p>后面的路径是一致的：<code>\bapps\2c0def96c5d44e159151b236de766892\build\libs</code></p>
</li>
<li><p>用解压工具打开<code>brida-all.jar</code>，将<code>/res</code>文件夹下的两个文件（<code>bridaServicePyro.py</code>、<code>scriptBridaDefault.js</code>）解压出来备用</p>
</li>
<li><p>编辑<code>bridaServicePyro.py</code>，将内容替换成以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> Pyro4</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pyro4.expose</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BridaServicePyro</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, daemon</span>):</span></span><br><span class="line">        self.daemon = daemon</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spawn_application</span>(<span class="params">self,application_id,frida_script,remote</span>):</span></span><br><span class="line"></span><br><span class="line">        self.application_id = application_id</span><br><span class="line">        self.frida_script = frida_script</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> remote == <span class="literal">True</span>:</span><br><span class="line">            self.device = frida.get_remote_device()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.device = frida.get_usb_device()</span><br><span class="line"></span><br><span class="line">        self.pid = self.device.spawn([self.application_id])</span><br><span class="line"></span><br><span class="line">        self.session = self.device.attach(self.pid)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> codecs.open(self.frida_script, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            source = f.read()</span><br><span class="line"></span><br><span class="line">        self.script = self.session.create_script(source)</span><br><span class="line">        self.script.load()</span><br><span class="line"></span><br><span class="line">        self.device.resume(self.pid)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reload_script</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> codecs.open(self.frida_script, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            source = f.read()</span><br><span class="line"></span><br><span class="line">        self.script = self.session.create_script(source)</span><br><span class="line">        self.script.load()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disconnect_application</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        self.device.kill(self.pid)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callexportfunction</span>(<span class="params">self, methodName, args</span>):</span></span><br><span class="line">        method_to_call = getattr(self.script.exports, methodName)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Take the Java list passed as argument and create a new variable list of argument</span></span><br><span class="line">        <span class="comment"># (necessary for bridge Python - Java, I think)</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">            s.append(i)</span><br><span class="line"></span><br><span class="line">        return_value = method_to_call(*s)</span><br><span class="line">        <span class="keyword">return</span> return_value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Pyro4.oneway</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shutdown</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;shutting down...&#x27;</span>)</span><br><span class="line">        self.daemon.shutdown()</span><br><span class="line"></span><br><span class="line">host = sys.argv[<span class="number">1</span>]</span><br><span class="line">port = int(sys.argv[<span class="number">2</span>])</span><br><span class="line">daemon = Pyro4.Daemon(host=host,port=port)</span><br><span class="line"></span><br><span class="line"><span class="comment">#daemon = Pyro4.Daemon(host=&#x27;127.0.0.1&#x27;,port=9999)</span></span><br><span class="line">bs = BridaServicePyro(daemon)</span><br><span class="line">uri = daemon.register(bs,objectId=<span class="string">&#x27;BridaServicePyro&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Ready.&quot;</span>)</span><br><span class="line">daemon.requestLoop()</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>bridaServicePyro.py</code>重新放回<code>brida_all.jar</code>的<code>/res</code>文件夹下（覆盖原文件）。</p>
</li>
<li><p>将<code>scriptBridaDefault.js</code>复制出来，并记住路径。</p>
</li>
</ol>
<p>至此，<code>Brida</code>的<code>Python3</code>适配部分完成。</p>
<h4 id="Brida配置"><a href="#Brida配置" class="headerlink" title="Brida配置"></a>Brida配置</h4><p>打开<code>Burpsuite</code>，切换到<code>Brida</code>选项卡，页面功能和用法可以参考<a href="https://bbs.pediy.com/thread-248977.htm">[原创]Brida操作指南</a>中的介绍。</p>
<p>“Python binary path”的值填写“环境准备”章节中安装的Python的位置。</p>
<p>Linux系统中，该路径为<code>~/.pyenv/versions/xxx/bin/python</code></p>
<p>Windows系统中，路径为安装的路径，如<code>C:\Users\xx\AppData\Local\Programs\Python\Python</code></p>
<p>此时，点击“Start Server”按钮，会显示绿色的“Server running”，表示<code>Pyro4</code>运行成功，可以进行操作了。</p>
<p><strong>大坑预警！大坑预警！大坑预警！</strong>重要的事情<strong>再说三遍</strong>！</p>
<p>对于“Frida JS file path”这个选项，各种教程里都没有提及它的含义，如果不管用它的默认值，或者指向自定义的脚本，都无法“Spawn application”。</p>
<p><img src="/2020/03/31/Python3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Brida%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/image-20200331160408482.png" alt="image-20200331160408482"></p>
<p>如果出现“getplatform”的错误，就说明是这个 JS 文件指定的有误。</p>
<p>在它的<a href="https://techblog.mediaservice.net/2018/04/brida-a-step-by-step-user-guide/">官方说明页面</a>中，有如下说明：</p>
<blockquote>“Frida JS file path” is the path of the Frida instrumentation JavaScript file, containing all Frida and Brida hooks and exports. To properly use Brida you have to insert the path of the JS file supplied with the Brida release (named “scriptBrida.js”) because this file contains Frida functions used by Brida itself. You can add your own Frida hooks and exports directly in this file.</blockquote>
简单翻译一下就是，这个`Frida JS file path`需要指向一个包含Frida和Brida定义的Hook和Export的 JS 文件。这个文件保存在`Brida-all.jar`中，就是上面步骤中保存的`scriptBridaDefault.js`文件。

<p>这里将“Frida JS file path”的地址指向之前保存的<code>scriptBridaDefault.js</code>文件的路径。</p>
<h4 id="配置Android设备并Spawn-application"><a href="#配置Android设备并Spawn-application" class="headerlink" title="配置Android设备并Spawn application"></a>配置Android设备并Spawn application</h4><p>最后一步，在Android设备上启动<code>frida-server</code>，在<code>Brida</code>中填好包名，“Spawn application”成功！</p>
<p><img src="/2020/03/31/Python3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Brida%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/image-20200331161726836.png" alt="image-20200331161726836"></p>
<p>点击<code>Analyze binary</code>标签页，选中<code>Binary</code>，点击<code>Load tree</code>按钮，列出加载的<code>.so</code>文件，成功！</p>
<p><img src="/2020/03/31/Python3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Brida%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/image-20200331164444141.png" alt="image-20200331164444141"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Frida</code>版本更新很快，因此虽然一两年前的工具，现在用起来也有诸多麻烦。在Linux平台上使用<code>pyenv</code> + <code>virtualenv</code>进行环境的管理配置会使配置简单很多。</p>
<p>另外，根据<code>Brida</code>作者的说法，在2020年6月会出一个支持<code>Python3</code>的官方版本，可以到时候关注一下Github。</p>
<p>整个过程总结起来就是：</p>
<ol>
<li>安装<code>Python</code>、<code>Frida</code>、<code>Pyro4</code></li>
<li>修改<code>Brida-all.jar</code>，更改<code>bridaServicePyro.py</code>文件；</li>
<li>提取<code>scriptBridaDefault.js</code>，修改<code>Frida JS file path</code>指向到提取的文件；</li>
<li></li>
</ol>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p>[1] Brida. <a href="https://github.com/federicodotta/Brida">https://github.com/federicodotta/Brida</a></p>
<p>[2] Frida. <a href="https://github.com/frida/frida">https://github.com/frida/frida</a></p>
<p>[3] [原创]Brida操作指南. <a href="https://bbs.pediy.com/thread-248977.htm">https://bbs.pediy.com/thread-248977.htm</a></p>
<p>[4] pyenv. <a href="https://github.com/pyenv/pyenv">https://github.com/pyenv/pyenv</a></p>
<p>[5] virtualenv. <a href="https://github.com/pyenv/pyenv-virtualenv">https://github.com/pyenv/pyenv-virtualenv</a></p>
<p>[6] Brida – A step-by-step user guide. <a href="https://techblog.mediaservice.net/2018/04/brida-a-step-by-step-user-guide/">https://techblog.mediaservice.net/2018/04/brida-a-step-by-step-user-guide/</a></p>
<p>[7] 《FRIDA操作手册》by <a href="https://github.com/hluwa">@hluwa</a> <a href="https://github.com/r0ysue">@r0ysue</a>. <a href="https://github.com/hookmaster/frida-all-in-one">https://github.com/hookmaster/frida-all-in-one</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Burpsuite</tag>
        <tag>Frida</tag>
        <tag>工具配置</tag>
      </tags>
  </entry>
  <entry>
    <title>RFID攻击方法梳理</title>
    <url>/2019/06/25/RFID%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>RFID（或者准确说是射频卡）的安全方面，既简单又复杂。简单在于其技术并没有那么复杂，因为算力、硬件限制、历史发展等因素的制约，导致不像蓝牙、WiFi这种有大量应用层的逻辑问题引发的漏洞，因此总结起来问题主要来源于认证和加密；而复杂在于标准、说法、名词众多，因此看不同的文章会有不同的说法，要准确理解并融会贯通还是有一定的难度。</p>
<p>下面我就简单梳理一下近期学习到的关于射频卡的一些基础知识，以及存在的相关攻击方法。</p>
<a id="more"></a>

<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>首先必须将RFID的基础知识说明，或者说将一些名词的定义事先约定，否则后面的表述会出现歧义，或者难以理解。本次参考的一个重点就是Freebuf上两个“神仙”打架的文章，感兴趣的可以去看原文（链接在文末）。</p>
<h2 id="名词、定义和概念"><a href="#名词、定义和概念" class="headerlink" title="名词、定义和概念"></a>名词、定义和概念</h2><h3 id="射频识别（RFID）"><a href="#射频识别（RFID）" class="headerlink" title="射频识别（RFID）"></a>射频识别（RFID）</h3><p>首先，先说明RFID的概念。在<a href="https://zh.wikipedia.org/wiki/%E5%B0%84%E9%A2%91%E8%AF%86%E5%88%AB">维基百科-RFID词条</a>下的定义：</p>
<blockquote>
<b>R</b>adio <b>F</b>requency <b>ID</b>entification一种无线通信技术，可以通过无线电信号识别特定目标并读写相关数据，而无需识别系统与特定目标之间建立机械或者光学接触。
</blockquote>

<p>所以RFID实际上并不只限于我们日常用的刷卡的“卡”，还有其他比如商品上的射频标签。</p>
<h3 id="IC卡和ID卡"><a href="#IC卡和ID卡" class="headerlink" title="IC卡和ID卡"></a>IC卡和ID卡</h3><p>这两者的关系，也是目前这一领域中争论最多的一个点。</p>
<p>ID卡，即IDentification Card，指的是身份识别卡，一般情况下是不可写入的感应卡，能读出固定的编号。（来源：<a href="https://baike.baidu.com/item/ID%E5%8D%A1">百度百科-ID卡</a> 词条）</p>
<p>IC卡，是Integrated Circuit Card的简称，即集成电路卡，又称智能卡（详见维基百科“<a href="https://zh.wikipedia.org/wiki/%E6%99%BA%E6%85%A7%E5%8D%A1">智能卡</a>”条目）。特点是可读写，容量大，有加密功能，数据记录可靠，使用方便。</p>
<h3 id="低频卡和高频卡"><a href="#低频卡和高频卡" class="headerlink" title="低频卡和高频卡"></a>低频卡和高频卡</h3><p>这里低频、高频的概念总是容易和IC卡、ID卡有所混淆。很多地方都把ID卡归类为低频卡，IC卡归类为高频卡，实际上这是错误的。</p>
<p>根据百度百科关于ID卡的描述，其工作频率有125KHz和13.56MHz两种不同的频段，因此高频和低频并不是区分ID和IC卡的方式。</p>
<p>RFID卡从空中接口上区分，大致有5种，分别有ISO/IEC制定的标准进行描述，截图来自 <a href="https://en.wikipedia.org/wiki/Radio-frequency_identification">维基百科-RFID</a> 词条：</p>
<p><img src="/2019/06/25/RFID%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/2019-06-27_105751.png" alt="RFID频率分类, from Wikipedia2"></p>
<p>简单翻译了一下，虽然WikiPedia上有中文词条，感觉翻译的不全（虽然我翻的版本可能不太准确）：</p>
<table>
<thead>
<tr>
<th>频带</th>
<th>规范</th>
<th>读取范围</th>
<th>数据速度</th>
<th>ISO/IEC 18000章节</th>
<th>备注</th>
<th>标签估价</th>
</tr>
</thead>
<tbody><tr>
<td>120 - 150 kHZ（低频）</td>
<td>无规定</td>
<td>10cm</td>
<td>低</td>
<td>Part 2</td>
<td>动物识别，工厂数据收集（比如迪卡侬衣服上的射频标签）</td>
<td>1美元</td>
</tr>
<tr>
<td>13.56 MHz（高频）</td>
<td>全世界通用ISM频段</td>
<td>10cm - 1m</td>
<td>低到中</td>
<td>Part 3</td>
<td>智能卡（ISO/IEC 15693, ISO/IEC 14443A, B）<br>非兼容ISO存储卡（Mifare Classic, iCLASS, Legic, Felica）<br>兼容性ISO微处理器卡（Desfire EV1, Seos）</td>
<td>0.5 - 5美元</td>
</tr>
<tr>
<td>433 MHz（甚高频）</td>
<td>近距设备（SDR）</td>
<td>1 - 100m</td>
<td>中</td>
<td>Part 7</td>
<td>使用主动标签的防御型应用（翻译的可能不准确）</td>
<td>5美元</td>
</tr>
<tr>
<td>865 - 868 MHz（欧洲）<br>902 - 928 MHz（北美）甚高频</td>
<td>ISM频段</td>
<td>1 - 12m</td>
<td>中到高</td>
<td>Part 6</td>
<td>欧洲商品编码，多种标准；识别和跟踪火车</td>
<td>0.15美元（被动式标签）</td>
</tr>
<tr>
<td>2450 - 5800 MHz（微波）</td>
<td>ISM频段</td>
<td>1 - 2m</td>
<td>高</td>
<td>Part 4</td>
<td>802.11 WLAN，蓝牙标准</td>
<td>25美元（主动标签）</td>
</tr>
<tr>
<td>3.1 - 10 GHz（微波）</td>
<td>超宽频</td>
<td>最高200m</td>
<td>高</td>
<td>未定义</td>
<td>需使用半主动或主动标签</td>
<td>设计为5美元</td>
</tr>
</tbody></table>
<p>从上表中可以看出，按照ISO给出的标准，卡片工作的频率范围其实有很多，因此直接从高频和低频对卡片或技术进行区分是不准确的。</p>
<div class="tip">
但是在日常生活中，大家接触到的ID卡一般都是125K的低频卡，而IC卡大多是13.56M的高频卡，因此就形成了固有的印象，认为ID卡都是低频卡，IC卡都是高频卡。
</div>

<h2 id="“白卡”和卡复制"><a href="#“白卡”和卡复制" class="headerlink" title="“白卡”和卡复制"></a>“白卡”和卡复制</h2><p>这个实际上是一种攻击手段，在这一节提出是因为一个“神奇的卡片”，被国外人称为”Chinese magic Card”的白卡。</p>
<p>理论上来说，卡片的<code>序列号</code>是不可更改的，各种百科和官方文档中也有提到：<code>卡号在封卡前写入后不可再更改，绝对确保卡号的唯一性和安全性</code>，但是有人制作了允许对卡片的序列号进行修改的卡片，导致了卡片的序列号非唯一，这也是有“复制卡”出现的原因。</p>
<p><img src="/2019/06/25/RFID%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/2019-06-27_120026.png" alt="某国外购物网站的Chinese magic card"></p>
<p>这是某国外的电商网站上出售的复制卡的条目，UID可更换的“Chinese Magic Card”</p>
<h1 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h1><h2 id="RFID伪造（卡号复制）"><a href="#RFID伪造（卡号复制）" class="headerlink" title="RFID伪造（卡号复制）"></a>RFID伪造（卡号复制）</h2><p>这里说卡号复制，实际上是从传统的ID卡复制而来。但是在实际生活中，对于ID卡和IC卡的使用没有区分的那么明显。以门禁为例，有些门禁就是使用ID卡，去识读卡片的序列号（或者说UID）进行判别；有些门禁会使用IC卡，但是并不在其中的存储扇区写入数据，故读卡器仍旧读取的是序列号。</p>
<p>因此这里统一使用“卡号复制”而不是ID卡复制来避免这一部分的歧义。</p>
<p>由于ID卡在设计之初就是将UID公开、不防护的，因此这部分没有任何的安全机制可言，尤其是出现了可以修改UID的“白卡”。</p>
<p>因为读取到UID即可完成卡片的复制，攻击者可以制作一个功率很大的天线，来延长射频卡的识读距离，可达到30cm甚至更远的距离，且该读取设备可以做的很小而增强便携性，放在手腕、公文包中靠近目标对象从而读取到其卡片信息（详见DefCon 21，RFID hacking live free or RFID hard）。</p>
<p><img src="/2019/06/25/RFID%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/2019-06-27_151718.png" alt="DefCon现场演讲视频截图"></p>
<h2 id="数据伪造"><a href="#数据伪造" class="headerlink" title="数据伪造"></a>数据伪造</h2><p>对于IC卡来说，卡片中提供了存储的能力。有些卡片中会存储与卡相关的信息，比如卡片余额，或者持有人的信息等。如果可以读出卡片中的数据，并且解析成有意义的字段并修改，然后重新写入卡中，就可以对卡片进行数据的伪造和篡改。</p>
<p>下面所提到的方法，都是关于Mifare Classic这种类型的卡的，其工作频率是13.56 MHz，符合ISO/IEC 14443A标准。常见的Mifare Classic有两种，<code>MF1 S50</code>和<code>MF1 S70</code>，S50有1K的存储空间，而S70有4K的存储。</p>
<h3 id="扇区、块和卡密"><a href="#扇区、块和卡密" class="headerlink" title="扇区、块和卡密"></a>扇区、块和卡密</h3><p>Mifare Classic卡片分为很多个扇区。S50有16个扇区，而S70有40个扇区。S50卡每个扇区分为4个块(Block)，而S70卡的扇区略有区别。两种卡片的存储结构如下图所示，可以看出两种卡的特点和关系：</p>
<p>S50卡的大致结构如下图（来源：<a href="https://www.nxp.com/docs/en/data-sheet/MF1S50YYX_V1.pdf">NXP官方文档 - MIFARE Classic EV1 1K</a>）<img src="/2019/06/25/RFID%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/2019-07-01_143104.png" alt="MIFARE Classic EV1 1K 扇区示意图"></p>
<p>S70卡的大致结构如下图（来源：<a href="https://www.nxp.com/docs/en/data-sheet/MF1S70YYX_V1.pdf">NXP官方文档 - MIFARE Classic EV1 4K</a>）<img src="/2019/06/25/RFID%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/14883779693311.png" alt="MIFARE Classic EV1 4K 扇区示意图"> 每个扇区的最后一个block是卡密（Key A和Key B）及访问控制字段。相关访问控制比较复杂，具体可以参见官方文档。</p>
<p><strong>0扇区的0块是厂商信息</strong>，包含了卡的UID。一般0扇区0块是不可写的，但是所谓的“白卡”就是0扇区0块可写的卡，是复制卡的基础。</p>
<p>其中，卡密是卡片校验读卡器权限的，其简单的交互流程如下：卡片产生一个随机数发送给读卡器，读卡器需按照算法计算出结果再发送给卡片，由卡片进行验证。验证通过之后，后续的交互都是用卡密进行加密的。借用BlackHat 2014的Slides中的一张图：<img src="/2019/06/25/RFID%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/2019-07-01_101637.png" alt="卡密校验流程"> </p>
<h3 id="Nested攻击"><a href="#Nested攻击" class="headerlink" title="Nested攻击"></a>Nested攻击</h3><p>因为复制卡只是复制了卡的UID，还需要将卡片扇区的数据都拿出来，因此需要知道每个扇区的卡密，才能读取到内容。引用<a href="https://www.freebuf.com/articles/terminal/128238.html">Freebuf上的相关文章</a>中的介绍：</p>
<blockquote>
<p>
简单地说，就是默认密码攻击。

</p><p>
由于M1卡片有16个扇区，在绝大多数情况下16个扇区不一定会同时使用到。于是根据厂商在出厂时预设的密码可能碰撞出其中某一个扇区的密码。

</p><p>
由于无源的M1卡每一次刷卡上电的时候，密钥交换采用的随机数都是“有规律”的，用已经碰撞出的某一扇区的密钥去试探其它扇区，在此时根据随机数的规律即可“套”出密码
</p>
</blockquote>

<h3 id="Darkside攻击"><a href="#Darkside攻击" class="headerlink" title="Darkside攻击"></a>Darkside攻击</h3><blockquote>
<p>
简单地说就是暴力破解，即爆破出某一个扇区的密钥，之后再使用Nested攻击就能Dump出整张卡。
</p><p>
而与通常意义上的暴力破解不同的是，由于M1卡片的认证机制，其会泄露部分认证信息，从而大大加快爆破的进度。
</p>
</blockquote>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>这其实不能算是RFID的攻击方式，但是很多相关的文章都有提及。实际上，在智能卡的攻击过程中，分析卡中数据的算法、校验等都是必须的过程，只有掌握了数据的构成方式，才能成功的进行数据的篡改。</p>
<h2 id="Fuzz攻击"><a href="#Fuzz攻击" class="headerlink" title="Fuzz攻击"></a>Fuzz攻击</h2><p>这类的攻击主要针对读卡器（Reader）。向读卡器模拟卡片进行数据的交互，给其发送非预期的数据，有可能造成缓冲区溢出等问题，进而可能产生代码执行等后果。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从整个大的RFID的方向上来看，其安全性主要在两块：卡复制（包括远程读取）和数据篡改。</p>
<p>由于出现了UID可改写的“白卡”，而且RFID在读取时无需用户授权，因此可能出现未授权的远距离读取并复制的可能。此外，像公交卡、饭卡等，如果使用时仅通过卡中数据进行识别和处理而没有实时与数据库数据校验的话，一旦卡片中的数据被破解，攻击者可以任意伪造数据并写入卡中，造成损失。</p>
<p>因此，在卡片的选择上，如果安全性要求比较高，应该选用CPU卡，而不应继续使用Mifare Classic 1K这种已知漏洞的卡片；其次，在认证卡片时，应增加更多的认证选项，而不是仅识读卡片的UID，比如使用某些扇区的数据进行辅助认证，同时认证卡类型等，避免简单的读取了UID后进行卡片复制。</p>
<p>存储上来说，尽量应该将数据加密后再保存在卡片中，避免明文数据直接存储，尽量增加攻击者对系统算法分析的难度；如有可能，应在刷卡的时候将数据与后台数据库的数据进行比对以提升安全性。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.blackhat.com/docs/sp-14/materials/arsenal/sp-14-Almeida-Hacking-MIFARE-Classic-Cards-Slides.pdf">Almeida M. Hacking Mifare Classic Cards[J]. blackhat, Sao Paulo, 2014.</a></p>
<p>[2] <a href="https://media.blackhat.com/us-13/US-13-Brown-RFID-Hacking-Live-Free-or-RFID-Hard-Slides.pdf">Brown F. RFID hacking: Live free or die hard, 2013[J]. Black Hat USA, 2013.</a></p>
<p>[3] <a href="https://www.nxp.com/products/identification-security/rfid/mifare-hf/mifare-classic:MC_41863#/">Mifare Classic 官方说明页面.</a></p>
<p>[4] <a href="https://www.freebuf.com/articles/terminal/128238.html">低成本安全硬件（二）：RFID on PN532. ya0guang@Freebuf.com, 2017.</a></p>
<p>[5] <a href="https://www.freebuf.com/articles/wireless/6580.html">RFID开发之圣诞老人无稽之谈.  chown@Freebuf.com, 2012.</a></p>
<p>[6] <a href="https://www.freebuf.com/articles/wireless/6588.html">RFID开发之圣诞袜的秘密. chown@Freebuf.com, 2012.</a></p>
<p>[7] <a href="https://en.wikipedia.org/wiki/Radio-frequency_identification">词条：“RFID”. Wikipedia.</a></p>
<p>[8] <a href="https://zh.wikipedia.org/wiki/MIFARE">词条：“Mifare”. Wikipedia.</a></p>
<p>[9] <a href="https://zh.wikipedia.org/wiki/%E6%99%BA%E6%85%A7%E5%8D%A1">词条：“智能卡”. Wikipedia.</a></p>
<p>[10] <a href="https://baike.baidu.com/item/ID%E5%8D%A1">词条：“ID卡”. 百度百科.</a></p>
]]></content>
      <tags>
        <tag>RFID</tag>
      </tags>
  </entry>
  <entry>
    <title>从防护视角谈XSS的成因、绕过和防御</title>
    <url>/2020/07/14/XSS%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>作为一名甲方的测试，日常会接触到很多不同的对XSS的修复方案。下面就从防护的视角来审视一下XSS攻击，以及一些绕过的姿势。</p>
<a id="more"></a>

<p>观前提示：本文面向对于XSS有所了解的人群，因此对XSS的基本原理介绍较少。如果是完全不懂XSS原理的萌新，建议先补一补基础知识，会有助于对本文内容的理解。</p>
<h2 id="XSS成因"><a href="#XSS成因" class="headerlink" title="XSS成因"></a>XSS成因</h2><p>对于XSS漏洞，可能是很多人Web安全的入门必学的知识点。XSS是跨站脚本（Cross-Site Scripting）的缩写，漏洞形成的根因是Web应用未能正确处理用户的输入，导致在页面展示内容包含用户输入的数据时，其中的HTML标签会被浏览器解析进而触发其中的恶意代码，造成危害。</p>
<p>简单来说，浏览器就是个憨憨，它会把所有交给它处理的内容都当成页面来解析。比如用户昵称部分，本来应该显示的是纯文本的信息，但攻击者在这里输入了一个<code>&lt;script&gt;</code>标签，浏览器接收到这个页面的源代码之后，会尝试解析全部能识别的HTML标签，那么攻击者输入的恶意JS代码就会被触发执行。</p>
<h3 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h3><p>众所周知，XSS分为 3 类：<strong>反射型XSS、存储型XSS 和 DOM型XSS</strong>。关于这三类XSS，网上有太多的介绍文章，就不在这里多说了。</p>
<p>补充一点，关于DOM型XSS，一般理解是反射型的一个分支，由于前端页面中的JS读取了URL中的数据并解析导致JS代码执行。</p>
<p>但是在Burpsuite的官网上，DOM型XSS有两个新的分类 <a href="https://portswigger.net/kb/issues">页面链接</a>：</p>
<p><img src="/2020/07/14/XSS%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97/image-20200716112413628.png" alt="image-20200716112413628"></p>
<p>不过本人对DOM型XSS的理解还是偏向于“数据不经过后端处理、直接由页面的JS读取后触发”这种解释。</p>
<h3 id="XSS成因-1"><a href="#XSS成因-1" class="headerlink" title="XSS成因"></a>XSS成因</h3><p>XSS形成的根因是将用户的输入原样输出在页面上，导致其中包含的HTML代码被解析进而执行脚本造成危害。</p>
<p>根据其出现的位置，可以分为三类：</p>
<h4 id="直接输出"><a href="#直接输出" class="headerlink" title="直接输出"></a>直接输出</h4><p>这种方式就是将用户的输入未进行任何处理直接输出到页面，攻击者可以直接输入<code>&lt;script&gt;</code>标签来运行JS代码，造成危害。</p>
<h4 id="闭合其他标签"><a href="#闭合其他标签" class="headerlink" title="闭合其他标签"></a>闭合其他标签</h4><p>这种情况大多发生在HTML标签属性中，以PHP为例，动态加载一个头像时，代码可能为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&#x27;&lt;?=$result[&quot;avatar&quot;]?&gt;&#x27;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>这时如果用户可以操作头像的URL地址，比如<code>http://test.com/1.jpg&#39;onerror=&#39;alert(/xss/)</code>，那么后端解析后，拼接到上述代码中就变成了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&#x27;http://test.com/1.jpg&#x27;</span> onerror=<span class="string">&#x27;alert(/xss/)&#x27;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>即可利用经典的onerror事件触发脚本执行。</p>
<h4 id="JS不安全的函数和属性使用"><a href="#JS不安全的函数和属性使用" class="headerlink" title="JS不安全的函数和属性使用"></a>JS不安全的函数和属性使用</h4><p>在构建前端页面时，可能因为业务功能需要，使用一些JavaScript的函数和属性，如<code>eval()</code>，<code>innerHTML</code>等，这些都可能触发用户输入中的恶意代码在页面的执行。</p>
<h2 id="XSS防护"><a href="#XSS防护" class="headerlink" title="XSS防护"></a>XSS防护</h2><p>理论上来说，只要在全局范围对用户输入进行转义，将危险字符全部转义掉就能有效避免XSS的发生。但实际业务中，功能上的限制并不能在每一个接口进行转义，尤其是对已有项目的XSS修复的时候。具体例子会在XSS修复的章节详述。</p>
<p><strong>请注意，这里说的防护措施均是在服务端进行的，单纯的前端防护无法有效的阻止XSS攻击的产生！</strong></p>
<p>目前来说防护的步骤分为识别和处理，其中识别大致有两类：关键字识别和正则表达式匹配；处理手段大致分为三类：拒绝、转义和过滤。</p>
<p><img src="/2020/07/14/XSS%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97/image-20200715165037812.png" alt="image-20200715165037812"></p>
<h3 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h3><p>在处理XSS漏洞之前，需要识别用户输入中是否含有“恶意代码”。识别中较为常见的是关键字/词匹配，如匹配用户输入的单引号(<code>&#39;</code>)，双引号(<code>&quot;</code>)、尖括号(<code>&lt; &gt;</code>)等，在很多的开源CMS中比较常见。这种识别方式可以有效对抗构建HTML标签的XSS攻击。更加极端的方式是关键词匹配，如<code>img</code>，<code>iframe</code>，甚至于<code>onload</code>、<code>onerror</code>都可能出现在匹配列表中。</p>
<p>但是，当有业务需要用户输入这些字符时，关键字匹配就无法胜任。因此有些情况下会用正则表达式匹配的方式来进行识别。比如曾经遇到过一个CMS会识别<code>&lt;xxx src=xxxx onxxx=xxxx</code>（<code>x</code>代表任意字符）模式的输入。这种类型的识别比较考验匹配列表的丰富程度，如果匹配条目不够多，很可能会被一些冷门的payload钻空子。</p>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>当识别到有黑名单字符的存在的时候，需要对这些内容进行处理。</p>
<p><strong>过滤</strong>就是简单的把识别到的内容删除掉，这种方式简单有效，但对用户体验上可能会有一定的影响，用户在输入完后无法感知那些内容被删除了，尤其是在输入文字较长或不能立刻给出反馈的场景下。比如用户新建某配置共分三步，在第一步输入配置名，此处会被过滤，用户在配置完成后查看才能看到最终的结果。</p>
<p><strong>拒绝</strong>是当识别到恶意代码时，拒绝用户的输入。这种处理方式更加的简单粗暴，用户体验不用多说肯定糟糕，但是防护效果可能是最好的（毕竟啥也没写入）。</p>
<p><strong>转义</strong>是将识别到的部分进行HTML转义，如<code>&lt;</code>转义成<code>&amp;lt;</code>，这样的处理比较温和，保留了用户的原始输入，但可能在跨平台（Web到APP）或系统间交互时较不友好。</p>
<h2 id="XSS绕过：寻找XSS注入点的思考和启发"><a href="#XSS绕过：寻找XSS注入点的思考和启发" class="headerlink" title="XSS绕过：寻找XSS注入点的思考和启发"></a>XSS绕过：寻找XSS注入点的思考和启发</h2><p>在寻找注入点的时候，网上有很多的文章给出了上百甚至上千条payload，虽然逐一尝试确实有可能找到注入点，但是耗时费力；尤其是模块众多，需要逐一确认的时候，简直会崩溃。因此需要使用某些方法来减少尝试的次数，快速判断是否存在注入的可能性。</p>
<p>首先，从防御视角出发，检测和处理用户输入有可能是WAF完成的，也有可能是程序本身的代码完成的。</p>
<p>WAF处理用户输入一般情况下采用代理（透明代理或反向代理）的方式进行，因此这种情况下往往就是直接处理（仅转义一次URL），而对于一些有编码的情况，或用JSON格式传输的接口来说，一般情况下非URL转义的编码是无法识别的（比如JSON中的<code>\u003c</code>）</p>
<p>如果在Web应用程序内部进行处理，有可能是在传输参数解析之后进行检查。</p>
<p>举个例子，如用户昵称修改的请求，使用JSON格式传输，正常请求中的参数如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;nickname&quot;</span>:<span class="string">&quot;Tester123&quot;</span>, <span class="attr">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果在<code>nickname</code>字段的值中输入<code>&lt;img src=x&gt;</code>，WAF识别规则是检测<code>&lt; &gt;</code>两个符号，此时发送请求后会直接被处理；但如果将payload变成<code>\u003cimg src=x\u003e</code>，对于WAF来说这段用户输入中没有关键字，则会放行。</p>
<p>此时，数据传输来到了Web应用程序内部，程序会使用类似于<code>json_decode</code>的函数对JSON字符串进行反序列化，得到一个数组。此时<code>\u003c</code>会在反序列化的过程中被转义，还原成<code>&lt;</code>符号而记录到数据库中。</p>
<h3 id="注入点分析"><a href="#注入点分析" class="headerlink" title="注入点分析"></a>注入点分析</h3><p>首先需要确认目标系统对XSS代码的识别规则和处理方法。识别规则的简单判断如下：</p>
<p><img src="/2020/07/14/XSS%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97/image-20200716162336622.png" alt="image-20200716162336622"></p>
<p>也有可能是多种方式的组合。</p>
<p>在尝试的时候可以先从完整的Payload开始，逐步删减来确认识别方式，如果你耐心足够，或者借助<code>Burpsuit</code>的Intruder，可以判断出识别了那些关键字/正则的模式。</p>
<p>处理方法可以在提交后看到，提示失败/关键字被吞/被转义。</p>
<p>此外，还需要确认最终的输出点是以怎样的方式展现。</p>
<h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>这种类型的XSS形成原因是服务端会将用户输入原样返回，打印在页面上。举个例子，比如搜索引擎会将用户搜索的关键字显示在结果页上。请求发送到了后端，服务器将用户输入的关键词包含在结果页面返回。比如我在百度搜索<code>xss</code>：</p>
<p><img src="/2020/07/14/XSS%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97/image-20200714170419065.png" alt="image-20200714170419065"></p>
<p>可以看到点击搜索之后，输入的关键字会在下一个页面中出现。</p>
<p><img src="/2020/07/14/XSS%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97/image-20200714170353842.png" alt="image-20200714170353842"></p>
<p>此时如果服务端未进行合理的处理，攻击者在输入的关键字中包含HTML标签，如<code>&lt;script&gt;</code>，则返回的页面中这部分内容会被浏览器解析，并执行其中的代码，形成攻击。</p>
<p>举个简单的例子，比如后端PHP代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span>($_GET[<span class="string">&#x27;a&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>这里需要补充说明一点，目前各大浏览器都有反射型XSS防护的功能，即浏览器会自动检测用户输入和页面的返回，如果检测到攻击的产生则会中断连接。</p>
<p><img src="/2020/07/14/XSS%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97/xss-demo.gif" alt="xss-demo"></p>
<p>需要注意的是，在Chrome 74版本之后，XSS Auditor 被移除了，所以想尝试的同学可以安装一个旧版本的Chrome。可参见《<a href="https://zhuanlan.zhihu.com/p/74288648">Google将删除Chrome内置的XSS保护（XSS Auditor）</a>》</p>
<h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>与反射型XSS类似，存储型XSS也是在页面上对用户输入进行了解析，不同的是存储型XSS数据来源是由服务端代码从数据库中读取出来的。比如之前提到过的用户昵称，用户设置的昵称是存储在服务端数据库的，当有用户访问到这个页面的时候，服务端会从数据库中读取数据，写入页面再发送到浏览器中。</p>
<p>相比于反射型，存储型XSS的攻击难度会相对较低。由于反射型XSS需要被害者“亲自”输入恶意代码，因此常用发送链接或利用CSRF等方式触发。而存储型只需要被害者访问到有漏洞的页面即可。比如之前的百度网盘的XSS：</p>
<p><img src="/2020/07/14/XSS%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97/v2-f29edc64907f224913714db1ab7f746b_720w.png" alt="img"></p>
<p>关于这个漏洞可参见《<a href="https://zhuanlan.zhihu.com/p/24249045">XSS实战：我是如何拿下你的百度账号</a>》</p>
<h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>DOM型XSS与反射型比较类似，可以看做反射型XSS的一个子类，但其区别是<strong>用户的输入是不经过服务端处理的</strong>。</p>
<p>在反射型XSS中，用户输入通过GET或POST方式发送到服务端，这些数据由服务端处理后再发回浏览器，触发脚本执行；而DOM型XSS则是完全由浏览器中的JavaScript处理用户输入，而不经过服务端。</p>
<p>这种情况多发生于页面中的JavaScript需要读取并处理URL时，或直接处理用户输入的时候（比如一些纯前端的在线小工具）。</p>
<h2 id="XSS成因-2"><a href="#XSS成因-2" class="headerlink" title="XSS成因"></a>XSS成因</h2><p>XSS形成的根因是将用户的输入原样输出在页面上，导致其中包含的HTML代码被解析进而执行脚本造成危害。</p>
<p>根据其出现的位置，可以分为三类：</p>
<h3 id="直接输出-1"><a href="#直接输出-1" class="headerlink" title="直接输出"></a>直接输出</h3><p>这种方式就是将用户的输入未进行任何处理直接输出到页面，攻击者可以直接输入<code>&lt;script&gt;</code>标签来运行JS代码，造成危害。</p>
<h3 id="闭合其他标签-1"><a href="#闭合其他标签-1" class="headerlink" title="闭合其他标签"></a>闭合其他标签</h3><p>这种情况大多发生在HTML标签属性中，以PHP为例，动态加载一个头像时，代码可能为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&#x27;&lt;?=$result[&quot;avatar&quot;]?&gt;&#x27;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>这时如果用户可以操作头像的URL地址，比如<code>http://test.com/1.jpg&#39;onerror=&#39;alert(/xss/)</code>，那么后端解析后，拼接到上述代码中就变成了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&#x27;http://test.com/1.jpg&#x27;</span> onerror=<span class="string">&#x27;alert(/xss/)&#x27;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>即可利用经典的onerror事件触发脚本执行。</p>
<h3 id="JS不安全的函数和属性使用-1"><a href="#JS不安全的函数和属性使用-1" class="headerlink" title="JS不安全的函数和属性使用"></a>JS不安全的函数和属性使用</h3><p>在构建前端页面时，可能因为业务功能需要，使用一些JavaScript的函数和属性，如<code>eval()</code>，<code>innerHTML</code>等，这些都会触发用户输入中的恶意代码在页面的执行。</p>
<h2 id="XSS修复"><a href="#XSS修复" class="headerlink" title="XSS修复"></a>XSS修复</h2><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>理论上来说，只要全局检测并处理掉单引号(<code>&#39;</code>)，双引号(<code>&quot;</code>)和尖括号(<code>&lt; &gt;</code>)这四个字符，就可以修复除JS<code>eval()</code>函数和转义的大部分XSS漏洞。但实际项目中，面临两个问题：一是某些接口的输入确实需要原样保存这些符号，二是全局的屏蔽会造成正常业务的异常。而如果对于已上线业务的修复，则会考虑到与其他模块的兼容性等问题，导致无法简单粗暴的应用这种策略。</p>
<p>对于Web页面来说，进行HTML转义，把&lt;转义成<code>&amp;lt;</code>是没问提的；但在安卓客户端，如果用户信息页面的昵称是放在TextView或者类似控件中显示的时候，会按照转义后的原文显示，显然是不符合用户需求的。如果把昵称设置为”&gt;.&lt;”的话，在移动端查看就会变成<code>&amp;gt;.&amp;lt;</code>。</p>
<p>这里写了一个简单的小例子来解释。Web端以PHP作为后端语言，移动端则用Android。</p>
<p>数据库中的原始数据（经过转义）后如下：</p>
<p><img src="/2020/07/14/XSS%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97/image-20200715155057546.png" alt="image-20200715155057546"></p>
<p>PHP代码如下，为展示方便用了HTML和PHP混写的方式，大佬勿喷 &gt;.&lt;</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line">$conn = mysqli_connect(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"><span class="comment">// 构建SQL语句</span></span><br><span class="line">$sql = <span class="string">&quot;select * from test&quot;</span>;</span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">$query = $conn-&gt;query($sql);</span><br><span class="line"><span class="comment">// 获取查询值</span></span><br><span class="line">$result = $query-&gt;fetch_array();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Test Page&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .container&#123;</span><br><span class="line">                margin: <span class="number">0</span> auto;</span><br><span class="line">                text-align: center;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">            &lt;!-- 填充头像 --&gt;</span><br><span class="line">            &lt;img src=<span class="string">&quot;&lt;?=$result[&quot;</span>avator<span class="string">&quot;]?&gt;&quot;</span>/&gt;</span><br><span class="line">            &lt;!-- 填充昵称 --&gt;</span><br><span class="line">            &lt;div&gt;<span class="meta">&lt;?=</span>$result[<span class="string">&quot;nickname&quot;</span>]<span class="meta">?&gt;</span>&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>该页面的内容如下：</p>
<p><img src="/2020/07/14/XSS%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97/image-20200715154911681.png" alt="image-20200715154911681"></p>
<p>目前一切正常，但是如果是用同样的数据<strong>原样填充</strong>到Android APP中，则会是下面这样：</p>
<p><img src="/2020/07/14/XSS%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97/image-20200715155243267.png" alt="image-20200715155243267"></p>
<p>瞬间爆炸。</p>
<p>当然，你可以说，这里不让用户昵称有特殊符号不就行了？那如果这是一个工程管理的系统，需要输入例如“温度&gt;25°C”这种字符呢？</p>
]]></content>
      <tags>
        <tag>XSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Ubertooth监听蓝牙通信</title>
    <url>/2019/06/19/%E4%BD%BF%E7%94%A8Ubertooth%E7%9B%91%E5%90%AC%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>作为没有使用过Ubertooth的小白，尝试从零开始搭建Ubertooth的环境，相关配置、依赖，来进行蓝牙数据的监听，配合Wireshark，进行蓝牙数据监听和分析。</p>
<a id="more"></a>

<h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><ul>
<li><p>VMWare版本：14.0.0 build-6661328</p>
</li>
<li><p>操作系统：Ubuntu 14.04.5 LTS</p>
</li>
<li><p>Ubertooth软件版本：ubertooth 2018-12-R1</p>
</li>
<li><p>Libbtbb版本：libbtbb 2018-12-R1</p>
</li>
<li><p>Wireshark版本： Version 2.6.6 (Git v2.6.6 packaged as 2.6.6-1~ubuntu14.04.0)</p>
</li>
</ul>
<p>本次编译安装的目的，是能够借助Wireshark去查看和分析监听到的蓝牙数据包，因此需要2个部分：Ubertooth（应用程序本体）和libbtbb（蓝牙基带库，源码中带有Wireshark插件）</p>
<p>实际上还有一部分需要关注，附带在Ubertooth下载的源码里，就是硬件对应的固件。由于固件是和软件配套的，因此在编译软件的时候需要给硬件刷入对应的固件，否则会报api不匹配的问题（下文中会说到）</p>
<h1 id="软件编译"><a href="#软件编译" class="headerlink" title="软件编译"></a>软件编译</h1><p>软件的编译部分其实很简单，使用Ubuntu系统的话官方git上是有相关说明的，而且很详细，可以傻瓜的照做。下面就简单说明一下。</p>
<p>首先先给出<a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">官方WiKi (Build-Guide)</a>的链接，如果阅读能力强的可以直接看官方说明，下面的描述都以Ubuntu为例。</p>
<p>首先安装编译环境，如cmake, gcc等，一条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cmake libusb-1.0-0-dev make gcc g++ libbluetooth-dev \</span><br><span class="line">pkg-config libpcap-dev python-numpy python-pyside python-qt4</span><br></pre></td></tr></table></figure>

<h2 id="libbtbb-蓝牙基带库"><a href="#libbtbb-蓝牙基带库" class="headerlink" title="libbtbb(蓝牙基带库)"></a>libbtbb(蓝牙基带库)</h2><p>接下来安装蓝牙基带库（Bluetooth Baseband Library），下载源码并解压，这里也是借用了官方给出的命令，正好我安装的也是2018-12-R1的版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/greatscottgadgets/libbtbb/archive/2018-12-R1.tar.gz -O libbtbb-2018-12-R1.tar.gz</span><br><span class="line">tar -xf libbtbb-2018-12-R1.tar.gz</span><br></pre></td></tr></table></figure>

<p>如果不用<code>wget</code>命令的话，也可以直接在<a href="https://github.com/greatscottgadgets/libbtbb/releases">Releases页面</a>上下载（注意版本和文件名哦），然后手动解压~~</p>
<p>接下来按照官方的说明，<code>cd</code>命令进入解压好的文件夹，使用<code>mkdir</code>命令新建一个名为<code>build</code>的文件夹，用于编译源码。之后就是简单粗暴的<code>make</code>过程。不过注意，最后的<code>make install</code>一定要用<code>sudo</code>去跑（长期用Kali已经忘记还有”以管理员身份运行“这回事了……）完整的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> libbtbb-2018-12-R1</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>如果没有报错，那就说明安装成功了。下面放出几张我build过程的截图：</p>
<p><img src="/2019/06/19/%E4%BD%BF%E7%94%A8Ubertooth%E7%9B%91%E5%90%AC%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/2019-06-17_135840.png" alt="执行cmake"></p>
<p><img src="/2019/06/19/%E4%BD%BF%E7%94%A8Ubertooth%E7%9B%91%E5%90%AC%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/2019-06-17_135948.png" alt="执行make命令"></p>
<p><img src="/2019/06/19/%E4%BD%BF%E7%94%A8Ubertooth%E7%9B%91%E5%90%AC%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/2019-06-17_140050.png" alt="执行make install"></p>
<p>根据官方说明，首次安装的时候可能会报错，或者出现找不到lib库的情况，此时则需要在命令行中执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<p>即可，虽然不知道为什么，而且我安装的时候并未出现任何报错的提示。</p>
<h2 id="Ubertooth工具软件"><a href="#Ubertooth工具软件" class="headerlink" title="Ubertooth工具软件"></a>Ubertooth工具软件</h2><p>Ubertooth工具软件就是指在命令行中输入<code>ubertooth-xxx</code>这样的命令能执行的那个玩意。编译的时候和libbtbb类似，用<code>wget</code>命令或者直接在<a href="https://github.com/greatscottgadgets/ubertooth/releases">Release页面</a>进行下载，并解压。官方的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/greatscottgadgets/ubertooth/releases/download/2018-12-R1/ubertooth-2018-12-R1.tar.xz</span><br><span class="line">tar xf ubertooth-2018-12-R1.tar.xz</span><br></pre></td></tr></table></figure>

<p>后面的步骤也是一样的，新建build文件夹，在这个文件夹里cmake - make - make install完成安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ubertooth-2018-12-R1/host</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<div class="tip">
需要注意的是，这里是在`host`文件夹下进行编译，解压出的源码中还有很多其他的文件夹，注意不要弄错了
</div>

<p>同样的，这里官方也给了提示，如果首次编译或报找不到lib库的问题，请在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<p>至此，基带和工具全部都安装完成了，这时候插上Ubertooth，将其分配给虚拟机，并在命令行中输入<code>ubertooth-util -v</code>即可查看到当前你的Ubertooth的固件版本。</p>
<p><img src="/2019/06/19/%E4%BD%BF%E7%94%A8Ubertooth%E7%9B%91%E5%90%AC%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/2019-06-17_142417.png" alt="查看Ubertooth固件版本"></p>
<p>这里是我已经刷过了固件，所以显示的版本是2018-12-R1（原来没刷固件之前忘记截图了），能看到固件，说明btbb库和Ubertooth工具都安装成功了。</p>
<h2 id="Wireshark插件"><a href="#Wireshark插件" class="headerlink" title="Wireshark插件"></a>Wireshark插件</h2><div class="tip">
<p>2019-06-19 更新:</p>
<p>
根据官方libbtbb github的 <a href="https://github.com/greatscottgadgets/libbtbb/issues/50">issus 50</a>，作者对Wireshark插件的问题进行了回答：
<ul>
<li>对于Wireshark 2.0之前的版本，需要编译<code>plugins-legacy</code>中的插件</li>
<li>对于Wireshark 2.0 ~ 2.2 的版本，需要编译<code>plugins</code>中的插件</li>
<li>对于Wireshark 2.2+的版本，无需编译任何插件即可，因为Wireshark官方已经自带了相关插件。</li>
</ul>
</p>
</div>

<div class="tip">
实际上下面所述的插件编译在我本次的流程中是没有成功的，可以直接略过。
</div>

<p><del>最终目的是要在Wireshark中实时查看到蓝牙监听到的数据包，因此需要Wireshark中的插件的支持。官方在libbtbb的源码压缩包中提供了相关的插件，路径在<code>libbtbb-2018-12-R1/wireshark/plugins/</code>下。2018-12-R1中有两个插件，<code>btbb</code>和<code>btbredr</code>。</del></p>
<p><del>首先需要安装<code>wireshark</code>。</del></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wireshark wireshark-dev libwireshark-dev cmake</span><br></pre></td></tr></table></figure>

<p><del>如果你已经安装了，就请忽略这步，并且找到其安装插件的目录。官方给出的默认路径在<code>/usr/lib/x86_64-linux-gnu/wireshark/libwireshark3/plugins</code>下，这也是下面命令中指定插件的安装路径。</del></p>
<p><del><em>我在编译的时候似乎没有找到这个路径，只找到了<code>/usr/lib/x86_64-linux-gnu/wireshark/</code>。根据官方Wiki的说明，需要找到与<code>asn1.so</code>或<code>ethercat.so</code>所在的路径。我在Ubuntu 14.04中使用<code>sudo apt-get install wireshark</code>命令安装的Wireshark的插件路径是在<code>/usr/lib/x86_64-linux-gnu/wireshark/plugin/2.6</code>这个路径下，所以下面命令中的路径填写我这个虚拟机中的路径，与官方Wiki的命令会有所出入。</em></del></p>
<p><del><em>我是使用<code>apt-get</code>命令安装的Wireshark，系统自动给我安装的是Wireshark Version 2.6.6 (Git v2.6.6 packaged as 2.6.6-1-ubuntu14.04.0) ，其插件是自动从<code>/usr/lib/x86_64-linux-gnu/wireshark/plugin/2.6</code>中加载的，支持子文件夹，因此我在这个路径下建立了一个文件夹<code>libbtbb</code>专门存放Ubertooth的插件。</em></del></p>
<p><del>首先安装btbb插件。进入btbb源码所在的路径，建立build文件夹，并指定安装路径(新建了一个插件目录<code>libbtbb</code>)：</del></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> libbtbb-2018-12-R1/wireshark/plugins/btbb</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_INSTALL_LIBDIR=/usr/lib/x86_64-linux-gnu/wireshark/plugins/2.6/libbtbb ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p><del>执行完<code>make install</code>命令后，在插件路径下是可以看到btbb.so这个文件的。<em>我的Wireshark是可以自动搜索子文件夹并加载插件，不确定其他版本的Wireshark是否也是这样。</em></del></p>
<p><del>下面安装BT BR/EDR插件，需要先将路径切回到libbtbb-2018-12-R1所在的那一级路径再执行下面的命令：</del></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> libbtbb-2018-12-R1/wireshark/plugins/btbredr</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_INSTALL_LIBDIR=/usr/lib/x86_64-linux-gnu/wireshark/plugins/2.6/libbtbb ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p><del>至此，Wireshark插件已经编译安装完毕。</del></p>
<h2 id="固件更新"><a href="#固件更新" class="headerlink" title="固件更新"></a>固件更新</h2><p>在使用之前，需要对Ubertooth硬件中的固件进行更新。上面Ubertooth tools部分提到了<code>ubertooth-util -v</code>命令可以查看到当前刷入的固件版本，同时有一个<code>API 版本</code>的问题，Ubertooth要求固件的API版本与Ubertooth tools的版本一致，否则不能使用。</p>
<p>在Ubertooth tools的源码中是包含了固件的，固件是<code>.dfu</code>格式的文件。源码中有可以直接用的固件，在<code>ubertooth-2018-12-R1/ubertooth-one-firmware-bin/bluetooth_rxtx.dfu</code>。更新固件的命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubertooth-dfu -d bluetooth_rxtx.dfu -r</span><br></pre></td></tr></table></figure>

<p>我在虚拟机中执行这一步的时候报错了，每次执行的时候都会尝试切换到DFU模式，然后USB显示无法识别，同时硬件上面的四个由深到浅的红色指示灯一直循环跑马灯。不知道这里是我虚拟机有问题，还是我的USB口有问题。</p>
<p><img src="/2019/06/19/%E4%BD%BF%E7%94%A8Ubertooth%E7%9B%91%E5%90%AC%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/2019-06-17_160303.png" alt="刷入固件报错"></p>
<p>尝试了很久都不成功之后，找了一台macbook，安装ubertooth tool，执行上面的命令，成功刷入。</p>
<p>这里官方给出了一个troubleshooting，如果有报错<code>libUSB Error: Command Error: (-1)</code>，或者硬件上面四个灯跑马灯的话，需要重新编译固件，就要用到<code>ubertooth-2018-12-R1/firmware</code>文件夹的内容了，编译命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ubertooth-2018-12-R1/firmware</span><br><span class="line">make clean all &amp;&amp; make</span><br><span class="line">ubertooth-dfu -r -d bluetooth_rxtx/bluetooth_rxtx.dfu</span><br></pre></td></tr></table></figure>

<p><em>在之前一直提示<code>Unable to find Ubertooth</code>错误的时候，我也尝试编译了固件，证明并不是固件的问题。由于没有成功刷入编译的固件，此部分不再赘述。</em></p>
<h1 id="抓包验证"><a href="#抓包验证" class="headerlink" title="抓包验证"></a>抓包验证</h1><h2 id="Wireshark设置"><a href="#Wireshark设置" class="headerlink" title="Wireshark设置"></a>Wireshark设置</h2><p>到了这一步，前期准备工作就都完成了。现在需要把Ubertooth和Wireshark进行联动，将Ubertooth收集到的数据传到Wireshark进行解析。这里主要参考<a href="https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark">官方Wiki</a>，步骤如下：</p>
<ol>
<li><p>在终端中运行命令：<code>mkfifo /tmp/pipe</code></p>
</li>
<li><p>打开Wireshark，选择 ‘Capture -&gt; Options’ 对抓包接口进行设置</p>
</li>
<li><p>点击右下角 ‘Manage Interfaces’ 对接口进行管理</p>
</li>
<li><p>切换到 ‘Pipes’ 选项卡</p>
</li>
<li><p>保存设置，选中 ‘/tmp/pipe’ 并点击开始</p>
</li>
<li><p>此时，在终端中运行命令：<code>ubertooth-btle -f -c /tmp/pipe</code></p>
</li>
</ol>
<p><img src="/2019/06/19/%E4%BD%BF%E7%94%A8Ubertooth%E7%9B%91%E5%90%AC%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/2019-06-17_162401.png" alt="操作示意图"></p>
<p>切回Wireshark，应该可以看到滚动的数据包了。</p>
<div class="tip">
这里有一点需要注意，“mkfifo /tmp/pipe” 命令需要在所有步骤前进行，即先创建pipe这个文件，再设置wireshark读取，最后用Ubertooth-btle命令写入，顺序错了是会不成功的
</div>

<h2 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h2><h3 id="DLT-147-check-your-Preferences-gt-Protocols-gt-DLT-USER"><a href="#DLT-147-check-your-Preferences-gt-Protocols-gt-DLT-USER" class="headerlink" title="DLT=147, check your Preferences-&gt;Protocols-&gt;DLT_USER"></a>DLT=147, check your Preferences-&gt;Protocols-&gt;DLT_USER</h3><p>这个问题我的个人理解是Wireshark没有能识别出这类数据包的具体类别，因此需要手动指定一下。</p>
<p>这个是没进行操作之前（有报错的时候）</p>
<p><img src="/2019/06/19/%E4%BD%BF%E7%94%A8Ubertooth%E7%9B%91%E5%90%AC%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/2019-06-17_151144.png" alt="DLT=147错误"></p>
<p>步骤很简单：</p>
<ol>
<li><p>点击 Edit -&gt; Preference (编辑 -&gt; 首选项)</p>
</li>
<li><p>在左侧选择 <code>Protocol</code>下的<code>DLT_USER</code>选项</p>
</li>
<li><p>点击<code>Edit</code>按钮</p>
</li>
<li><p>点击左下角的 “+” 添加一条记录，在<code>DLT</code>处选择DLT=147，<code>Payload protocol</code>部分双击修改，填入btle，点击OK保存</p>
</li>
</ol>
<p>此时显示就正常了。</p>
<p><img src="/2019/06/19/%E4%BD%BF%E7%94%A8Ubertooth%E7%9B%91%E5%90%AC%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/2019-06-17_163721.png" alt="修复步骤"></p>
<p>这是修复过的样子：</p>
<p><img src="/2019/06/19/%E4%BD%BF%E7%94%A8Ubertooth%E7%9B%91%E5%90%AC%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/2019-06-17_163522.png" alt="修复了DLT=147的界面"></p>
<h3 id="undefined-symbol-new-create-dissector-handle"><a href="#undefined-symbol-new-create-dissector-handle" class="headerlink" title="undefined symbol: new_create_dissector_handle"></a>undefined symbol: new_create_dissector_handle</h3><p>这个问题是在Wireshark 2.2+版本下按照官方Build Guide编译插件后造成的。原因在上面的插件编译那一节已经说到了，2.2+版本可以直接用，不需要进行任何插件的编译工作。</p>
<p>因为折腾了很久才明白各个版本之间的区别，因此还是在这里提一句，记录一下。</p>
<p>下面是这个错误报错的截图：</p>
<p><img src="/2019/06/19/%E4%BD%BF%E7%94%A8Ubertooth%E7%9B%91%E5%90%AC%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/2019-06-18_193005.png" alt="Wireshark插件报错截图"></p>
]]></content>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python搭建反向代理分析IoT设备流量</title>
    <url>/2020/04/16/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90IoT%E8%AE%BE%E5%A4%87%E6%B5%81%E9%87%8F/</url>
    <content><![CDATA[<p>反向代理的概念和应用早已不是什么稀奇玩意了。但是在测试过程中，对于那些无法配置代理，使用了HTTPS的设备，想要分析流量还是比较困难的。借助反向代理，则可以降低这一过程的难度，轻松获取到想要的数据。</p>
<p>本文是接续“Frida抓包”和“利用泄露的HTTPS证书”这两篇文章的后续，将这两篇文章中提到的技术进行了简化和实现和拓展，提供一种新的测试思路。</p>
<a id="more"></a>

<h2 id="故事的开始"><a href="#故事的开始" class="headerlink" title="故事的开始"></a>故事的开始</h2><p>书接上文。在使用Apache配置了反向代理，利用Proxifier转发流量并使用Burpsuite抓包后，发现这一流程非常麻烦，且难以在其他领域复现。比如测试目标是IoT设备，无法接入设备修改Hosts文件，则较难引导流量。</p>
<p>虽然说ARP攻击也是可以完成的，但是很容易在局域网内引起网络拥堵、丢包等情况：总是会觉得设备响应变慢，用Wireshark抓包的时候看到一大片重传包（不知道是不是哪里设置的不对，如果有大佬知道还烦请指点一二）。</p>
<p>因此想到使用DNS欺骗的方法来引导流量，并搭建反向代理，在出口上指定Proxy到Burpsuite，这样就可以在一个程序里完成全部操作，省时省力。</p>
<h2 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h2><p>这里的DNS欺骗其实是有歧义的。一般意义上说DNS欺骗，大体就是两种：篡改Hosts和本地DNS劫持。</p>
<p><strong>篡改Hosts</strong>：这种方法并不通用，很多设备都无法修改Hosts文件，如IoT设备、未Root的安卓/iOS设备等。</p>
<p><strong>本地DNS劫持</strong>：这种方式使用ARP引导流量，过滤出其中的DNS请求，将要篡改的域名进行响应。一般用Ettercap工具去做（如果一定要劫持推荐试试Bettercap），但是仍然没跳出ARP的范畴。</p>
<p>因此这里选用了一个门槛略高但方式更加温和的思路：伪造DNS服务器。</p>
<p>门槛高是因为这种方式需要接触设备/路由器，将其中的首选DNS服务器地址设置成本机的IP，而温和是因为这种方式并不会对局域网流量造成任何影响。使用ARP攻击，局域网内会有大量的假ARP请求，且目标机器的流量全部会经过本机，而我们感兴趣的可能只是其中很小很小很小的一部分。</p>
<h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><p>既然确定了思路，下面就是动手环节了，先搭建一个DNS服务器。</p>
<h3 id="写一个简易DNS服务器"><a href="#写一个简易DNS服务器" class="headerlink" title="写一个简易DNS服务器"></a>写一个简易DNS服务器</h3><p>为什么要自己写一个？不用现成的？</p>
<p>这两个疑问可能是很多人（包括我自己）都会提出的，毕竟重复造轮子是一件很没有意义和效率的事情。但是基于我找到的DNS服务器搭建都是很复杂的方案，比如<code>Bind9</code>，<code>Windows Server</code>等等，尝试过后发现复杂且难用（压根就没配置成功过），于是一气之下就打算自己写一个。</p>
<p>原理很简单，在本地监听53端口，当流量到达的时候按照DNS的协议解析，将要查询的域名提取出来，根据本地的规则匹配后返回IP，并封装成DNS应答发送出去。</p>
<p><img src="/2020/04/16/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90IoT%E8%AE%BE%E5%A4%87%E6%B5%81%E9%87%8F/image-20200423164654717.png" alt="image-20200423164654717"></p>
<p>在查询DNS解析协议的时候，发现网上竟然有类似的Python代码，虽然说性能肯定不行，但是毕竟承载的设备数量不多，自己测试用肯定没问题。</p>
<p>于是拿来主义，Copy过来源码，简单调试一下，成功！</p>
<p>在此声明一下，这段源码在很多不同的博客或社区都有转载，但是无一例外都没注明作者。在进一步搜索之后，某一个博客页面上转载的代码里有一句注释，表明这个代码的作者是<code>@author: RobinTang</code>，不知道我这样使用是否侵权~原始代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Created on 2012-10-15</span></span><br><span class="line"><span class="string">@author: RobinTang</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS Query</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinDNSQuery</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        self.name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            d = data[i]</span><br><span class="line">            <span class="keyword">if</span> d == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> d &lt; <span class="number">32</span>:</span><br><span class="line">                self.name = self.name + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.name = self.name + chr(d)</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        self.querybytes = data[<span class="number">0</span>:i + <span class="number">1</span>]</span><br><span class="line">        (self.type, self.classify) = struct.unpack(<span class="string">&#x27;&gt;HH&#x27;</span>, data[i + <span class="number">1</span>:i + <span class="number">5</span>])</span><br><span class="line">        self.len = i + <span class="number">5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getbytes</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.querybytes + struct.pack(<span class="string">&#x27;&gt;HH&#x27;</span>, self.type, self.classify)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS Answer RRS</span></span><br><span class="line"><span class="comment"># this class is also can be use as Authority RRS or Additional RRS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinDNSAnswer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ip</span>):</span></span><br><span class="line">        self.name = <span class="number">49164</span></span><br><span class="line">        self.type = <span class="number">1</span></span><br><span class="line">        self.classify = <span class="number">1</span></span><br><span class="line">        self.timetolive = <span class="number">190</span></span><br><span class="line">        self.datalength = <span class="number">4</span></span><br><span class="line">        self.ip = ip</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getbytes</span>(<span class="params">self</span>):</span></span><br><span class="line">        res = struct.pack(<span class="string">&#x27;&gt;HHHLH&#x27;</span>, self.name, self.type, self.classify, self.timetolive, self.datalength)</span><br><span class="line">        s = self.ip.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        res = res + struct.pack(<span class="string">&#x27;BBBB&#x27;</span>, int(s[<span class="number">0</span>]), int(s[<span class="number">1</span>]), int(s[<span class="number">2</span>]), int(s[<span class="number">3</span>]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS frame</span></span><br><span class="line"><span class="comment"># must initialized by a DNS query frame</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinDNSFrame</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        (self.id, self.flags, self.quests, self.answers, self.author, self.addition) = struct.unpack(<span class="string">&#x27;&gt;HHHHHH&#x27;</span>, data[<span class="number">0</span>:<span class="number">12</span>])</span><br><span class="line">        self.query = SinDNSQuery(data[<span class="number">12</span>:])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getname</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.query.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setip</span>(<span class="params">self, ip</span>):</span></span><br><span class="line">        self.answer = SinDNSAnswer(ip)</span><br><span class="line">        self.answers = <span class="number">1</span></span><br><span class="line">        self.flags = <span class="number">33152</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getbytes</span>(<span class="params">self</span>):</span></span><br><span class="line">        res = struct.pack(<span class="string">&#x27;&gt;HHHHHH&#x27;</span>, self.id, self.flags, self.quests, self.answers, self.author, self.addition)</span><br><span class="line">        res = res + self.query.getbytes()</span><br><span class="line">        <span class="keyword">if</span> self.answers != <span class="number">0</span>:</span><br><span class="line">            res = res + self.answer.getbytes()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># A UDPHandler to handle DNS query</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinDNSUDPHandler</span>(<span class="params">socketserver.BaseRequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        data = self.request[<span class="number">0</span>].strip()</span><br><span class="line">        dns = SinDNSFrame(data)</span><br><span class="line">        socket = self.request[<span class="number">1</span>]</span><br><span class="line">        namemap = SinDNSServer.namemap</span><br><span class="line">        <span class="keyword">if</span>(dns.query.type==<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># If this is query a A record, then response it</span></span><br><span class="line"></span><br><span class="line">            name = dns.getname();</span><br><span class="line">            <span class="keyword">if</span> namemap.__contains__(name):</span><br><span class="line">                <span class="comment"># If have record, response it</span></span><br><span class="line">                dns.setip(namemap[name])</span><br><span class="line">                socket.sendto(dns.getbytes(), self.client_address)</span><br><span class="line">            <span class="keyword">elif</span> namemap.__contains__(<span class="string">&#x27;*&#x27;</span>):</span><br><span class="line">                <span class="comment"># Response default address</span></span><br><span class="line">                dns.setip(namemap[<span class="string">&#x27;*&#x27;</span>])</span><br><span class="line">                socket.sendto(dns.getbytes(), self.client_address)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># ignore it</span></span><br><span class="line">                socket.sendto(data, self.client_address)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># If this is not query a A record, ignore it</span></span><br><span class="line">            socket.sendto(data, self.client_address)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS Server</span></span><br><span class="line"><span class="comment"># It only support A record query</span></span><br><span class="line"><span class="comment"># user it, U can create a simple DNS server</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinDNSServer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, port=<span class="number">53</span></span>):</span></span><br><span class="line">        SinDNSServer.namemap = &#123;&#125;</span><br><span class="line">        self.port = port</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addname</span>(<span class="params">self, name, ip</span>):</span></span><br><span class="line">        SinDNSServer.namemap[name] = ip</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        HOST, PORT = <span class="string">&quot;0.0.0.0&quot;</span>, self.port</span><br><span class="line">        server = socketserver.UDPServer((HOST, PORT), SinDNSUDPHandler)</span><br><span class="line">        server.serve_forever()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now, test it</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sev = SinDNSServer()</span><br><span class="line">    sev.addname(<span class="string">&#x27;www.aa.com&#x27;</span>, <span class="string">&#x27;192.168.0.1&#x27;</span>)    <span class="comment"># add a A record</span></span><br><span class="line">    sev.addname(<span class="string">&#x27;www.bb.com&#x27;</span>, <span class="string">&#x27;192.168.0.2&#x27;</span>)    <span class="comment"># add a A record</span></span><br><span class="line">    sev.addname(<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>) <span class="comment"># default address</span></span><br><span class="line">    sev.start() <span class="comment"># start DNS server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Now, U can use &quot;nslookup&quot; command to test it</span></span><br><span class="line"><span class="comment"># Such as &quot;nslookup www.aa.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>这段代码在Win Python 3.7环境下是没问题，可以正常响应，但是有两个问题：</p>
<ol>
<li>只能对域名进行精准匹配，无法使用<code>*</code>通配符；</li>
<li>对于没有指定的域名，若设置了<code>default address</code>，则会一律返回该地址，否则就不回复</li>
</ol>
<p>在使用过程中，我需要让这个服务器对于我没指定的地址回复真实地址，这样可以保证被欺骗设备的其他业务是正常的（业务间可能存在关联性，某一业务无法访问可能导致其他业务停止），同时通配符可以减少统计域名的麻烦，也不会漏掉流量。</p>
<p>针对以上两点，对源代码进行了部分的修改（修改详情可参考文末的连接）。</p>
<h3 id="写一个反向代理服务器"><a href="#写一个反向代理服务器" class="headerlink" title="写一个反向代理服务器"></a>写一个反向代理服务器</h3><p>虽然使用Apache + Proxifier可以转流量，但是用到的工具多不易排错，且当需要修改配置时，Apache配置文件的查询、新增都相对麻烦。</p>
<p>反向代理转发的思路也很简单：因为DNS欺骗，客户端会把流量发到本机，因此</p>
<ol>
<li>本机监听端口，将收到的HTTP(S)流量解析；</li>
<li>取出Host字段中的目标域名、端口，重组新的请求发出；</li>
<li>获取服务端响应</li>
<li>发送给客户端</li>
</ol>
<p><img src="/2020/04/16/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90IoT%E8%AE%BE%E5%A4%87%E6%B5%81%E9%87%8F/image-20200423171132217.png" alt="image-20200423171132217"></p>
<p>既然要求便捷且不考虑性能，直接用Python的<code>http.server</code>模块构建一个HTTP服务器接收请求即可。</p>
<p>重写<code>http.server.BaseHTTPRequestHandler</code>模块，对其中的HTTP方法处理进行重写即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span>(<span class="params">http.server.BaseHTTPRequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">req</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(self.request, ssl.SSLSocket):</span><br><span class="line">                scheme = <span class="string">&quot;https://&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                scheme = <span class="string">&quot;http://&quot;</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 根据Host信息重组URL</span></span><br><span class="line">            self.url = scheme + self.headers[<span class="string">&quot;host&quot;</span>].strip(<span class="string">&quot;\n&quot;</span>) + self.path</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断是否有HTTP Body</span></span><br><span class="line">            <span class="keyword">if</span> self.headers.__contains__(<span class="string">&#x27;Content-Length&#x27;</span>):</span><br><span class="line">                data = self.rfile.read(int(self.headers[<span class="string">&#x27;Content-Length&#x27;</span>]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                data = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">            req = requests.Request(method=self.command, url=self.url, headers=self.headers, data=data)</span><br><span class="line">            s = requests.Session()</span><br><span class="line">            prepped = req.prepare()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将请求通过代理发送出去</span></span><br><span class="line">            r = s.send(prepped, verify=<span class="literal">False</span>,proxies=proxies, allow_redirects=<span class="literal">False</span>, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 设置对客户端的响应头</span></span><br><span class="line">            self.send_response(r.status_code)</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> r.headers:</span><br><span class="line">                self.send_header(key, r.headers[key])</span><br><span class="line">            self.end_headers()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 写入Response Body，写完后会自动发出这个请求</span></span><br><span class="line">            self.wfile.write(r.content)</span><br><span class="line">        <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            self.send_error(<span class="number">404</span>, <span class="string">&#x27;file not found: %s&#x27;</span> % self.path)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.req()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_POST</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.req()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_HEAD</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.req()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_OPTIONS</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.req()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_PUT</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.req()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_DELETE</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.req()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_MOVE</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.req()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_TRACE</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.req()</span><br></pre></td></tr></table></figure>

<p><code>http.server.BaseHTTPRequestHandler</code>模块会读取当前请求的<code>HTTP Method</code>，并调用<code>do_xxx</code>函数来进行处理。在这里我们并不需要对不同Method进行差异化处理，我们只想安安静静把他们转发出去，因此下面的<code>do_xxx</code>全部都调用<code>req()</code>统一进行处理。</p>
<p>完整代码已上传Github：<a href="https://github.com/mactavishmeng/mitmserver">https://github.com/mactavishmeng/mitmserver</a></p>
<p>Github上的版本是将DNS服务器和反代服务器集成在一起，通过配置文件<code>mitmserver.json</code>来进行配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;proxies&quot;</span> : &#123;<span class="attr">&quot;http&quot;</span>: <span class="string">&quot;http://127.0.0.1:8080&quot;</span>,</span><br><span class="line">               <span class="attr">&quot;https&quot;</span>:<span class="string">&quot;http://127.0.0.1:8080&quot;</span>&#125;,</span><br><span class="line">  <span class="attr">&quot;dns_list&quot;</span> : [</span><br><span class="line">        &#123;<span class="attr">&quot;host&quot;</span>: <span class="string">&quot;www.baidu.cn&quot;</span>, <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;192.168.1.3&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">&quot;host&quot;</span>: <span class="string">&quot;*.baidu.cn&quot;</span>, <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;192.168.1.3&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">&quot;host&quot;</span>: <span class="string">&quot;www.google.com&quot;</span>, <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;192.168.1.3&quot;</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">  <span class="attr">&quot;dns_query_enable&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;http_list&quot;</span> : [</span><br><span class="line">        &#123;<span class="attr">&quot;address&quot;</span>:<span class="string">&quot;0.0.0.0&quot;</span>, <span class="attr">&quot;port&quot;</span>:<span class="number">80</span>, <span class="attr">&quot;ishttps&quot;</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">&quot;address&quot;</span>:<span class="string">&quot;0.0.0.0&quot;</span>, <span class="attr">&quot;port&quot;</span>:<span class="number">443</span>, <span class="attr">&quot;ishttps&quot;</span>:<span class="literal">true</span>, <span class="attr">&quot;certfile&quot;</span>:<span class="string">&quot;./certificate.crt&quot;</span>, <span class="attr">&quot;keyfile&quot;</span>:<span class="string">&quot;./private_key.key&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个配置文件中可以轻易的对各个部分进行方便的调整，如配置的代理，本地监听的HTTP(S)端口，证书，DNS列表等。</p>
<h2 id="实战验证"><a href="#实战验证" class="headerlink" title="实战验证"></a>实战验证</h2><p>实际使用中，整个流程的核心有两点：DNS如何欺骗，HTTPS证书是否是真的。</p>
<h3 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h3><p>虽然上面说了那么多，还写了一个DNS服务器，<strong>但是如果你的路由器支持插件，可以自定义hosts</strong>，实际上是不需要这么麻烦的。比如我借到的这台极路由：</p>
<p><img src="/2020/04/16/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90IoT%E8%AE%BE%E5%A4%87%E6%B5%81%E9%87%8F/image-20200423193023221.png" alt="image-20200423193023221"></p>
<p>直接用插件强行更改设备的DNS查询结果，不过有些路由器不支持修改Hosts，并不通用。</p>
<ol>
<li><p>手机、PC等可直接修改网络配置的设备</p>
<p>对于手机APP来说，可以直接在“无线局域网”中将IP设置修改为“静态”，在DNS服务器部分配置IP为本机即可。以安卓为例：</p>
<p><img src="/2020/04/16/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90IoT%E8%AE%BE%E5%A4%87%E6%B5%81%E9%87%8F/image-20200423173255950.png" alt="image-20200423173255950"></p>
</li>
<li><p>IoT设备等无法直接修改配置的设备</p>
<p>而IoT设备因为无法在设备上操作，需要在路由器上设置（如果能获得控制权的话）。</p>
<p>将路由器的DNS设置为本机IP即可（不同路由器界面可能不同，但原理是一样的）：</p>
<p><img src="/2020/04/16/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90IoT%E8%AE%BE%E5%A4%87%E6%B5%81%E9%87%8F/image-20200423192754552.png" alt="image-20200423192754552"></p>
</li>
</ol>
<p>至此，设备端DNS欺骗的前置步骤完成。</p>
<h3 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h3><p>打开<code>mitmserver.json</code>，修改其中的监听端口的配置。</p>
<p>如这里监听的APP通信，它与三个域名进行HTTPS通信，其中两个域名访问443，一个域名访问9988。此时配置列表里需打开两个监听端口（443、9988），并将<code>&quot;ishttps&quot;</code>的值设置为<code>true</code>，表示这个端口监听HTTPS。后面的<code>certfile</code>和<code>keyfile</code>部分填入证书和私钥文件的路径。</p>
<p>如果你没有这两个文件，可以从Burpsuite等抓包工具中导出，或使用openssl工具生成自签名证书。</p>
<h3 id="开始抓包"><a href="#开始抓包" class="headerlink" title="开始抓包"></a>开始抓包</h3><p>在本机上配置好要监听的端口、要劫持的域名、填入Burpsuite的地址后，即可开始抓包。</p>
<p>此处以某安卓APP为例，因为已经做了证书校验的绕过，所以这里的HTTPS证书是随意找了一个来配置的（毕竟已经绕过校验）。配置文件如下：</p>
<p><img src="/2020/04/16/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90IoT%E8%AE%BE%E5%A4%87%E6%B5%81%E9%87%8F/image-20200424101749926.png" alt="image-20200424101749926"></p>
<p>运行起来：</p>
<p><img src="/2020/04/16/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90IoT%E8%AE%BE%E5%A4%87%E6%B5%81%E9%87%8F/image-20200424102218780.png" alt="image-20200424102218780"></p>
<p>对应在Burpsuite中拦截到的请求：</p>
<p><img src="/2020/04/16/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90IoT%E8%AE%BE%E5%A4%87%E6%B5%81%E9%87%8F/image-20200424102421991.png" alt="image-20200424102421991"></p>
<p>这样仅需一个py文件就完成了全部的复杂流程。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Burpsuite</tag>
        <tag>反向代理</tag>
        <tag>MiTM</tag>
        <tag>DNS劫持</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Frida手动绕过Android-APP证书校验</title>
    <url>/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>HTTPS证书校验绕过有很多成熟的方法，比如SSL Unpinning，JustTrustMe等，但是遇到混淆过或写在so里的校验的时候是无效的。</p>
<p>本文写的可能会有些啰嗦，记录了我整个尝试的思路。没有直接写绕过方法，是想给其他和我一样的萌新提供一些思路，如有不妥之处大佬们轻喷。</p>
<a id="more"></a>

<p>最近买了一个TP-Link的摄像头，顺便下载的它配套的安卓应用，想看看这个应用在与服务器交互的时候都发了些啥，因此准备抓包。当我把姿势都摆好了之后，却发现它的流量在<code>Burpsuite</code>里完全没出现。</p>
<p>好的吧，我知道可能你是校验了证书。</p>
<p>掏出祖传的<code>XPosed</code>插件<code>SSL Unpinning</code>，竟然没用。emmmm，那可能是进行了混淆，XPosed在Hook的时候需要特定的包名，如果包名被混淆了自然是Hook不到的嘛。</p>
<h2 id="代理流量"><a href="#代理流量" class="headerlink" title="代理流量"></a>代理流量</h2><p>在系统里配置了代理却抓不到包，很有可能是因为APP有限制，禁止流量走代理。因为我是在模拟器上安装了这个APP，因此想到了强行代理这个模拟器的流量，看看会怎样。</p>
<p>测试中用的是<code>雷电模拟器</code>，流量转发用的是<code>Proxifier</code>。因此在<code>Proxifier</code>中配置需要拦截流量的进程名为<code>LdBoxHeadless.exe</code>的进程，来强行转发流量到我们的Burp上：</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200409202521746.png" alt="image-20200409202521746"></p>
<p>转发成功，现在尝试一下请求，比如找回密码功能，点击“完成”后，返回的提示竟然是“网络连接失败”？？？</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200409202728285.png" alt="image-20200409202728285"></p>
<p>同时，Burp收到警告，提示<code>Failed to negotiate a TLS connect to xxx</code>，表示HTTPS握手过程失败。</p>
<p>好吧，果然是限制了流量同时也校验了证书。</p>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>既然发生了错误，那应该会有相应的报错日志，看看能不能从日志里看出点端倪。</p>
<p>进入<code>adb shell</code>，先输入<code>ps</code>命令查看对应进程的pid，比如这里是 <code>2035</code> ，在用<code>logcat | grep 2035</code>来过滤出该进程的日志即可。</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200410143906742.png" alt="image-20200410143906742"></p>
<p>此时再点击完成按钮，提示“网络连接失败”，查看logcat打出来的日志，发现了证书错误的信息：</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200410144046644.png" alt="image-20200410144046644"></p>
<h2 id="反编译dex"><a href="#反编译dex" class="headerlink" title="反编译dex"></a>反编译dex</h2><p>看到相关的报错日志，如果有反编译出来的伪代码，看看能不能搜到相关报错的日志的语句来定位到相关代码段，顺藤摸瓜找到校验的函数，再去Hook岂不美滋滋~</p>
<p>先尝试一下反编译，来看看是不是被混淆过。解压<code>apk</code>，使用<code>dex2jar</code>将<code>classes.dex</code>转换成<code>.jar</code>格式，再用<code>Java Decompiler</code>查看。看到包名的时候，发现它确实进行了混淆。</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200409201406531.png" alt="image-20200409201406531"></p>
<p>但是并没有看到和常见的 HTTP 相关的组件（比如<code>OKHttp3</code>）相关的包。</p>
<p>将报错日志的部分拆成关键词来搜索也完全搜不到相关的地方，非常让人怀疑实际上这部分逻辑就没写在Java层，很有可能在so里。</p>
<h2 id="分析so"><a href="#分析so" class="headerlink" title="分析so"></a>分析so</h2><p>既然如此，进入apk包中的lib文件夹，看看它加载的so里有没有什么特别之处。从so文件的大小和名称中，第一眼就识别到了<code>libIPCAppContextJNI.so</code>文件。果断拖到ida中看看里面有什么。</p>
<p>在ida中加载完之后，果断的打开Strings Window来暴搜字符串。输入<code>verify error:num</code>，看看我发现了什么！</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200410144726512.png" alt="image-20200410144726512"></p>
<p>跟进这个字符串的调用，F5，顺利找到打出这句日志的代码：</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200410144929216.png" alt="image-20200410144929216"></p>
<p>但是，这个函数是一个回调函数，函数名为<code>TPSSLManager::SSLCtxVerifyCallback</code>，追踪它的调用也没有找到有验证证书相关的操作，似乎又陷入僵局……</p>
<p>因为对证书校验的实现不是很熟悉，打破僵局的方法只能求助于度娘。看到那句日志打印的上一行<code>X509_verify_cert_error_string</code>函数，抱着死马当活马医的心态，扔进搜索引擎，竟然搜到了一堆OPENSSL的证书校验的示例代码！</p>
<p>通过示例代码的注释，发现OPENSSL校验证书的函数名为<code>X509_verify_cert</code>，回到ida里搜了一下，Bingo！</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200410150004769.png" alt="image-20200410150004769"></p>
<p>跟进这个函数被调用的地方看了下，和示例代码一样，都是在用<code>if</code>语句在判断这个函数的返回值是1还是0，那初步确认证书校验的点就在此处。</p>
<h2 id="Frida-Hook"><a href="#Frida-Hook" class="headerlink" title="Frida Hook"></a>Frida Hook</h2><p>由于测试是在雷电模拟器里做的，因此需要下载并运行x86版本的<code>Frida-server</code>。给萌新的一个小提示：Frida运行需要关闭SELinux，可以在adb shell中输入<code>setenforce 0</code>来关闭它。</p>
<h3 id="确认函数地址"><a href="#确认函数地址" class="headerlink" title="确认函数地址"></a>确认函数地址</h3><p>在写JS脚本之前，先使用Frida的命令行来确认一下要Hook的模块和函数是否可用（个人觉得这样便于调试）。在PC端的命令行输入<code>frida -U com.tplink.ipc</code>连接.</p>
<p>进入后输入<code>Module.findExportByName(&quot;libIPCAppContextJNI.so&quot;, &quot;X509_verify_cert&quot;)</code>应该能打印出<code>X509_verify_cert</code>函数的入口地址，但是竟然返回的是<code>null</code>。此时有点慌了，难道我的判断出错了吗？</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200410151702592.png" alt="image-20200410151702592"></p>
<p>果断使用<code>Process.enumerateModules()</code>命令，会在命令行中打印出所有的模块（即加载的so），找了一下发现也没有<code>libIPCAppContextJNI.so</code>，甚至路径几乎都是<code>/system/lib</code>这样系统路径下的文件。</p>
<p>在这里我卡了很久，搜了很多文章，都没有发现问题出在哪了，简直一度就要放弃了，直到我想要不要换真机试一下……简直峰回路转！全都成功了，顺利打印出地址：</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200410151802418.png" alt="image-20200410151802418"></p>
<h3 id="脚本编写-amp-Hook"><a href="#脚本编写-amp-Hook" class="headerlink" title="脚本编写 &amp; Hook"></a>脚本编写 &amp; Hook</h3><p>接下来就可以编写JS代码来进行Hook了，代码内容也很简单，就是修改这个函数的返回值，让它永远等于1即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nativePointer = Module.findExportByName(<span class="string">&quot;libIPCAppContextJNI.so&quot;</span>, <span class="string">&quot;X509_verify_cert&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;-------------Start-------------&quot;</span>);</span><br><span class="line">    Interceptor.attach(nativePointer, &#123;</span><br><span class="line">        onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 此处是修改入参要做的逻辑，在这里不需要修改，留空即可</span></span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;----------leaving-------------&quot;</span>)</span><br><span class="line">            <span class="comment">// 打印原始的返回值</span></span><br><span class="line">            <span class="built_in">console</span>.log(retval);</span><br><span class="line">            <span class="comment">// replace修改返回值</span></span><br><span class="line">            retval.replace(<span class="number">0x1</span>)</span><br><span class="line">            <span class="comment">// 再次打印出来验证一下修改是否成功</span></span><br><span class="line">            <span class="built_in">console</span>.log(retval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>把这个文件保存，我命名为<code>hook.js</code>。开启Frida，在忘记密码那里点几下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(frida) pentest@DESKTOP<span class="literal">-2AE07FJ</span>:~/frida<span class="variable">$</span> frida <span class="literal">-U</span> com.tplink.ipc <span class="literal">-l</span> hook.js</span><br><span class="line">     ____</span><br><span class="line">    / _  |   Frida <span class="number">12.8</span>.<span class="number">17</span> - A world<span class="literal">-class</span> dynamic instrumentation toolkit</span><br><span class="line">   | (_| |</span><br><span class="line">    &gt; _  |   Commands:</span><br><span class="line">   /_/ |_|       help      -&gt; Displays the help system</span><br><span class="line">   . . . .       object?   -&gt; Display information about <span class="string">&#x27;object&#x27;</span></span><br><span class="line">   . . . .       <span class="keyword">exit</span>/quit -&gt; <span class="keyword">Exit</span></span><br><span class="line">   . . . .</span><br><span class="line">   . . . .   More info at https://www.frida.re/docs/home/</span><br><span class="line">Attaching...</span><br><span class="line">------------<span class="literal">-Start</span>-------------</span><br><span class="line">[<span class="type">MI</span> <span class="number">5</span><span class="type">s</span>::<span class="type">com.tplink.ipc</span>]-&gt; ---------<span class="literal">-leaving</span>-------------</span><br><span class="line"><span class="number">0</span>x1</span><br><span class="line"><span class="number">0</span>x1</span><br></pre></td></tr></table></figure>

<p>Nice！成功Hook到并打印了返回值。</p>
<h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>到这一步，已经接近成功了，但是在系统里设置代理之后它并不会走，判断应该是做了代理上的限制，导致APP的流量不跟随代理。</p>
<p>那这一步的目标，就是让APP的流量顺利走到PC的Burpsuite上，来帮助我们进行分析。</p>
<p>第一种思路自然是找出限制代理的部分，一并Hook掉，但是我实在是不想再去找了，于是果断放弃；</p>
<p>第二种思路是通过无线网卡共享一个热点，再配置转发达到抓包的目的。这种方法在Windows系统下配置很麻烦，放弃；</p>
<p>第三种思路是PC端配置反向代理，手机端通过修改<code>hosts</code>文件强行转流量，因为之前的测试中配置过，且配置也简单（就是操作步骤有点复杂，好在环境都在），就果断用了。</p>
<p>反向代理是要配置证书的，但是因为Hook掉了校验，所以配置什么证书也无所谓了~</p>
<h3 id="配置Hosts"><a href="#配置Hosts" class="headerlink" title="配置Hosts"></a>配置Hosts</h3><p>配置hosts文件需要知道域名，在分析校验的部分看到了对于<code>*.tplinkcloud.com.cn</code>域名的校验。因此再次用Strings暴搜：</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200410160228733.png" alt="image-20200410160228733"></p>
<p>因为考虑到可能不同的功能会访问不同的域名，为了方便起见，一次性把这些域名都添加到<code>hosts</code>文件里。</p>
<p>在修改<code>hosts</code>文件的时候，需要注意编写的格式。可以先通过<code>adb pull /etc/hosts</code>将原始的hosts文件下载到PC，再在这个基础上修改。在“回车”符号上一定要注意，Android只识别<code>\n</code>而无法识别<code>\r\n</code>，因此在编辑的时候一定要注意回车符。</p>
<p>我使用的是<code>Notepad++</code>来进行编辑，注意右下角：</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200410160643053.png" alt="image-20200410160643053"></p>
<p>如果不是LF的话，可以双击这个位置选择“转换为Unix格式”即可。</p>
<p>编辑完后再<code>adb push</code>回原位并重启即可生效。</p>
<h3 id="开始抓包！"><a href="#开始抓包！" class="headerlink" title="开始抓包！"></a>开始抓包！</h3><p>终于在经过无数失败之后，可以开始抓包了。</p>
<p>如果以上步骤都配置正确的话，此时打开APP，在PC上输入命令<code>frida -U com.tplink.ipc -l hook.js</code>后，点击相应的按钮，在命令行里会出现一串这样的输出：</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200410161021863.png" alt="image-20200410161021863"></p>
<p>每一个输出都代表一个请求的证书校验被绕过了。</p>
<p>打开Burpsuite，终于能看到熟悉的请求了：</p>
<p><img src="/2020/04/12/%E5%88%A9%E7%94%A8Frida%E6%89%8B%E5%8A%A8%E7%BB%95%E8%BF%87Android-APP%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C/image-20200410161204206.png" alt="image-20200410161204206"></p>
<p>接下来就可以尽情的发挥脑洞开始测试了！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个思路其实非常简单，主要是这个APP没有进行过加固，分析起来比较方便，so的函数名都很全，所以在分析这一步中并没有太大难度。总体思路总结如下：</p>
<ol>
<li>通过反编译等方式确定证书绑定的核心函数的位置</li>
<li>使用Frida对该核心函数进行Hook</li>
<li>如果遇到无法代理的情况，嫌麻烦可以用反向代理的方式抓包</li>
</ol>
]]></content>
      <tags>
        <tag>Burpsuite</tag>
        <tag>Frida</tag>
        <tag>工具配置</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>泄露的网站证书和私钥？来做些有趣的事吧！</title>
    <url>/2020/03/26/%E5%88%A9%E7%94%A8%E6%B3%84%E9%9C%B2%E7%A7%81%E9%92%A5%E8%BF%9B%E8%A1%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>网站配套有APP，因为做了SSLPinning，因此用Burpsuite代理抓包会报错：</p>
<p><code>The client failed to negotiate a TLS connection to xxx.com:443 : Remote host closed connection during handshake</code></p>
<p>既然这样，利用泄露的证书和私钥来一个“完美”中间人不就行了！</p>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在正式实战之前，先介绍一下接下来用到的技术中的一些基本概念：正向代理、反向代理、DNS解析和HTTPS证书。</p>
<h3 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h3><p>代理分为正向和反向两种。</p>
<p><strong>正向代理</strong>，也被称之为转发代理，是一种比较常见的代理方式。一般情况下，正向代理（转发代理）用于某个区域的网络（如公司内网）无法直接访问互联网环境，或者被墙等原因，需要借助正向代理服务器来间接的访问。需要使用正向代理的主机需要配置代理服务器的IP。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15372908-cfc6d3fd67598b12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/830/format/webp" alt="img"></p>
<p>比如常用的<code>Burpsuite</code>，就可以看做正向代理服务器，在使用的时候需要把浏览器的代理地址配置到<code>Burpsuite</code>指定的IP和端口上，如默认配置的<code>127.0.0.1:8080</code>。</p>
<p><strong>反向代理</strong>是一种客户端无感知的代理方式，一般用在负载均衡或业务转发的场景中。比如某网站有两台服务器，<code>服务器A</code>为Web服务器，<code>服务器B</code>为邮件服务器。因此在总的出口上配置反向代理，对于<code>http://example.com/web</code>的请求就转发到<code>服务器A</code>，而<code>http://example.com/mail</code>的请求就转发到<code>服务器B</code>。</p>
<p><img src="/2020/03/26/%E5%88%A9%E7%94%A8%E6%B3%84%E9%9C%B2%E7%A7%81%E9%92%A5%E8%BF%9B%E8%A1%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/image-20200317193457759.png" alt="2020-03-17_192900"></p>
<p>总的来说，<strong>正向代理</strong>是隐藏客户端，对于服务器来说发起访问的是代理服务器；而<strong>反向代理</strong>是隐藏了服务端，比如上面的例子中，用户只对<code>http://example.com</code>有感，而对背后的两台实际处理业务的服务器无感。</p>
<p>反向代理的实现有很多，常见的是<code>Apache</code>或<code>Nginx</code>。</p>
<p>详细的解释可参见：<a href="https://blog.csdn.net/hungry0_0/article/details/78928082">代理与反向代理，以及其应用场景</a>和<a href="https://www.jianshu.com/p/ae76c223c6ef">Nginx正向代理与反向代理</a>。</p>
<h3 id="HTTPS证书"><a href="#HTTPS证书" class="headerlink" title="HTTPS证书"></a>HTTPS证书</h3><p>HTTPS证书如果展开细说，内容实在有点多，涉及到对称加密、非对称加密、公钥基础设施（PKI）等等概念。此处默认大家已经了解这些概念，不再过多叙述，感兴趣的可参考<a href="https://zhuanlan.zhihu.com/p/27395037">HTTPS系列干货（一）：HTTPS 原理详解</a>。</p>
<p>此处需提及的是，在申请HTTPS证书后，一般会得到两个文件：<code>.crt</code>的证书文件，和<code>.key</code>的私钥文件。证书文件是会在请求的时候发到客户端的，私钥文件是用来解密客户端协商密钥的加密数据的。</p>
<h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS解析就是将域名转换成IP的过程。因为域名更容易记忆，因此人们日常上网的时候都会去使用域名访问网站，输入域名后就需要把它对应的IP地址检索出来，这一过程就涉及到DNS解析。</p>
<p>改变DNS解析结果有多种方式：</p>
<ul>
<li><p><strong>修改Hosts文件</strong></p>
<p>这种方法日常会经常用到，比如屏蔽某个软件的广告时就会把广告服务器的域名加入hosts文件，并将其对应的IP设置为<code>0.0.0.0</code>。Hosts文件在Windows中通常位于<code>C:\Windows\System32\drivers\etc\hosts</code>，而Linux一般在<code>/etc/hosts</code>文件夹下。</p>
</li>
<li><p><strong>修改DNS服务器地址</strong></p>
<p>这种方法需要自己搭建一个DNS服务器，将要解析的域名和对应地址写入配置文件，再将系统的DNS服务器地址指向该服务器，这样就可以按照自定义的规则解析域名的地址了。</p>
</li>
<li><p><strong>DNS投毒</strong></p>
<p>DNS投毒一般在局域网攻击中使用，通过ARP攻击引导受害者流量，并响应其中的DNS请求，返回攻击者定义的地址。</p>
</li>
</ul>
<h2 id="攻击准备"><a href="#攻击准备" class="headerlink" title="攻击准备"></a>攻击准备</h2><p>首先，需要事先进行一些准备工作。</p>
<p>攻击的前提，需要获取到目标站点的私钥文件，即上节中提到的<code>.key</code>文件。实际的测试过程中，很幸运的在某个配置备份文件中发现了，且有效期还有一年多，足以做很多奇奇怪怪的事了~</p>
<p>其次，构想一下整个攻击的网络模型。由于是一个中间人攻击，因此主要有三方：受害者（<code>victim</code>，简称V），中间人（<code>Man-in-the-Middle</code>，简称M）和服务器（<code>Server</code>，简称S）。主要的思路是，要引导 <code>V</code> 的流量经过 <code>M</code> 转发到 <code>S</code>。其中 <code>M</code> 需要有解开HTTPS密文的能力。</p>
<p><img src="/2020/03/26/%E5%88%A9%E7%94%A8%E6%B3%84%E9%9C%B2%E7%A7%81%E9%92%A5%E8%BF%9B%E8%A1%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/image-20200326190216345.png" alt="image-20200326190216345"></p>
<p>是不是乍一看觉得，这不是<code>Burpsuite</code>或者<code>SSLStrip</code>干的事吗！</p>
<p>但是！这些工具都有一个致命缺陷：会有“站点不安全”的警告！</p>
<p><img src="/2020/03/26/%E5%88%A9%E7%94%A8%E6%B3%84%E9%9C%B2%E7%A7%81%E9%92%A5%E8%BF%9B%E8%A1%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/image-20200324212039174.png" alt="image-20200324212039174"></p>
<p>如果是日常测试，或者安全研究可以通过<strong>安装证书解决</strong>，但是其他场景下无法安装证书，或者软件做了<strong>HTTPS证书绑定</strong>，这种方式就失效了。</p>
<p>虽然说证书绑定可以通过各种方法绕过，比如Android App可以用<code>Xposed</code>框架的<code>Just Trust Me</code>、<code>SSL Unpinning</code>之类的插件，但是有些情况下这些通用插件不起作用，又懒得hook（比如我）而“恰巧”获取到了网站证书……</p>
<p>攻击的拓扑图大致如下：</p>
<p><img src="/2020/03/26/%E5%88%A9%E7%94%A8%E6%B3%84%E9%9C%B2%E7%A7%81%E9%92%A5%E8%BF%9B%E8%A1%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/image-20200326191141220.png" alt="image-20200326191141220"></p>
<p>在 <code>M</code> 上搭建反向代理，并投毒DNS，让 <code>V</code> 访问服务器 <code>example.com</code> 的时候将IP地址解析成 <code>M</code> 的地址。这样流量到达 <code>M</code> 的时候通过反向代理。</p>
<p>由于反向代理上配置了证书，因此在流量到达时会尝试进行密钥协商，并处理加密流量。此时，反向代理出口的流量即为明文状态，攻击者即可对此部分流量进行拦截、修改和查看等，再转发到真实服务器上。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="DNS投毒"><a href="#DNS投毒" class="headerlink" title="DNS投毒"></a>DNS投毒</h3><p>上文中提到过，投毒方式有很多种，当然也各有优劣。</p>
<p><strong>DNS劫持</strong>：在实际攻击中可以使用<code>bettercap</code>进行DNS投毒的操作。这种方法对受害者无感，且无需接触受害者设备。</p>
<p><strong>修改DNS服务器</strong>：在有接触路由器或受害者设备的情况下可用此种方式。如果路由器自动分配DNS，则可以直接修改规则将分配的首选DNS设置到攻击者布置的DNS服务器的IP上。</p>
<p>DNS服务器搭建，有条件可以选用<code>Windows Server</code>进行（原生自带），或者使用软件<code>ISC BIND 9</code>来进行，这类教程网上很多，在此不在赘述。</p>
<p><strong>修改Hosts文件</strong>：一般在本地测试或者验证的时候用这种方式，操作简单，影响面小（仅有本机会被影响）。</p>
<p>本次实验即选用修改Hosts文件的方式，简单快捷。</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理的架设方法很多，比如利用<code>Nginx</code>或者<code>Apache</code>。由于电脑上装了<code>xampp</code>，本次使用<code>Apache</code>作为反向代理服务器。下面的配置基于<code>xampp v3.2.4</code>的默认配置。</p>
<ol>
<li><p>将证书（后缀<code>.crt</code>）和私钥（后缀<code>.key</code>）文件复制到xampp路径下。记住这两个文件的路径。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">F:\xampp\apache\conf\ssl.crt\test.crt</span><br><span class="line">F:\xampp\apache\conf\ssl.key\test.key</span><br></pre></td></tr></table></figure>

<p>这个是按照<code>Apache</code>默认存放证书的位置放进去的。当然放在哪不重要，因为这两个文件的位置是要在配置中指定的。</p>
</li>
<li><p>进入<code>xampp</code>安装目录，编辑\apache\conf\httpd.conf`文件，添加配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:443&gt;</span><br><span class="line">    ServerName  example.com</span><br><span class="line">    ServerAlias example.com</span><br><span class="line">    SSLEngine on</span><br><span class="line">    SSLProxyEngine On</span><br><span class="line">    SSLProxyVerify none</span><br><span class="line">    SSLProxyCheckPeerCN off</span><br><span class="line">    SSLProxyCheckPeerName off</span><br><span class="line">    SSLProxyCheckPeerExpire off</span><br><span class="line">    SSLCertificateFile &quot;F:\xampp\apache\conf\ssl.crt\test.crt&quot;</span><br><span class="line">    SSLCertificateKeyFile &quot;F:\xampp\apache\conf\ssl.key\test.key&quot;</span><br><span class="line">    &lt;Proxy *&gt;</span><br><span class="line">       Order deny,allow</span><br><span class="line">       Allow from all</span><br><span class="line">    &lt;&#x2F;Proxy&gt;</span><br><span class="line">    ProxyPreserveHost On</span><br><span class="line">    ProxyRequests Off</span><br><span class="line">    ProxyPass &#x2F;  https:&#x2F;&#x2F;example.com&#x2F;</span><br><span class="line">    ProxyPassReverse &#x2F; https:&#x2F;&#x2F;example.com&#x2F;</span><br><span class="line">&lt;&#x2F;VirtualHost&gt;</span><br></pre></td></tr></table></figure>

<p>其中<code>example.com</code>是目标服务器的域名，两个文件路径就是第一步拷贝进来的证书和私钥的地址。</p>
</li>
<li><p>启动<code>Apache</code>，此时访问<code>https://127.0.0.1</code>，会显示“此站点不安全”的警告，点忽略后会显示<code>example.com</code>(第二步中配置的域名)的内容。</p>
</li>
</ol>
<p>这样就算反向代理配置成功。</p>
<h3 id="控制流量"><a href="#控制流量" class="headerlink" title="控制流量"></a>控制流量</h3><p>反向代理出口流量就是明文的了，如果不去管它，会自动被代理转发到服务端。因此这里需要一个机制去拦截、查看和修改流量，达到操纵流量的目的。</p>
<p>本实验在<code>Windows</code>平台下进行，因此使用的是Win平台的软件，Linux平台可找同类软件替换，毕竟真理是不会变的嘛。</p>
<p><a href="https://baike.baidu.com/item/proxifier/10859305?fr=aladdin"><strong>Proxifier</strong></a>是一款功能非常强大的socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链。通过这个软件，可以将<code>Apache</code>中的流量转发出来。</p>
<p>关于这个软件的安装使用不过多做介绍，只说一下<strong>代理规则</strong>的配置。这里对<code>Apache</code>的全部流量进行拦截，因此在“应用程序”栏中填写<code>httpd.exe</code>（这个是<code>Apache</code>处理请求的进程），如下：</p>
<p><img src="/2020/03/26/%E5%88%A9%E7%94%A8%E6%B3%84%E9%9C%B2%E7%A7%81%E9%92%A5%E8%BF%9B%E8%A1%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/image-20200326200451393.png" alt="image-20200326200451393"></p>
<p>流量最终是被代理到<code>Burpsuite</code>上，因为这款软件对数据包修改比较友好，比如<code>Repeater</code>、<code>Intruder</code>等模块都可以方便的对请求进行重放、暴破等。</p>
<h3 id="流量操纵"><a href="#流量操纵" class="headerlink" title="流量操纵"></a>流量操纵</h3><p>这部分其实不用过多介绍，运行起来之后只需要在<code>Burpsuite</code>中查看获取的流量并进行操作即可。</p>
<p>至此，整个中间人过程完毕，虽然有点繁琐（反代接<code>Proxifier</code>再接<code>Burp</code>），应该可以再优化，但奈何本人才疏学浅，只能想到这种方式来利用，希望有大神可以指点。</p>
<p>在中间人端（<code>M</code>端）流量的关系如下：</p>
<p><img src="/2020/03/26/%E5%88%A9%E7%94%A8%E6%B3%84%E9%9C%B2%E7%A7%81%E9%92%A5%E8%BF%9B%E8%A1%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/image-20200326202158832.png" alt="image-20200326202158832"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这种中间人攻击的方式利用难度很大，但是可以完美的对抗证书认证类的校验，比如APP校验服务端证书。可以利用的场景也比较有限（临近网络）。</p>
<p>写此文的目的有两个，一是分享一下整个攻击的过程，毕竟这种类型的攻击并没有太多提及；二是提醒一下泄露了网站证书的管理员，不要以为仅仅删除了泄露出去的备份文件就安全了，证书泄露的后果还是很严重的。</p>
]]></content>
      <tags>
        <tag>MiTM</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>校园生活APP渗透记录</title>
    <url>/2020/11/07/%E6%A0%A1%E5%9B%AD%E7%94%9F%E6%B4%BBAPP%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>最近使用校园生活这个APP给电动车充电，发现这个APP界面简陋，而且必须在校园网里才能连上服务器登录（外网环境无法使用，必须要拨VPN连进校园网才行）。最坑爹的是，这个APP并不支持iOS，必须用安卓手机才能安装，而我目前主力鸡是iPhone，之前的安卓机没有电话卡又不能上网，每次充电都必须带两个手机，iPhone开热点给安卓机联网，安卓机还要拨号VPN，着实麻烦，于是就想着有没有啥方法可以用iOS去控制充电。</p>
<a id="more"></a>

<p>正好前段时间渗透测试的课上说到以前有同学黑进了学校的邮件系统，想到一般情况下内部系统可能都没啥安全防护措施，就打算试一试，看看能不能分析一波登录和请求，然后再尝试搞个客户端或者Web端的。</p>
<h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>首先想到的是用Burpsuite对这个APP的流量进行分析，看看能不能捡个漏，通过抓包的方法来找到URL或者API，如果是内嵌Web的就更方便了，如果不是的话搞下API也许也能搞得定。</p>
<p>在模拟器里装好APP，设置代理到Burpsuite，开抓！</p>
<p><img src="/2020/11/07/%E6%A0%A1%E5%9B%AD%E7%94%9F%E6%B4%BBAPP%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95/image-20201107160012091.png" alt="image-20201107160012091"></p>
<p>发现登录请求是一个长成这样子的东西，看起来很像Base64编码后的数据，可是用Base64解码并没有看到有用的东西：</p>
<p><img src="/2020/11/07/%E6%A0%A1%E5%9B%AD%E7%94%9F%E6%B4%BBAPP%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95/image-20201107160505582.png" alt="image-20201107160505582"></p>
<p>好吧，到这一步只能盲猜是加密了，将加密后的Hex数据Base64编码。</p>
<h2 id="逆向APK"><a href="#逆向APK" class="headerlink" title="逆向APK"></a>逆向APK</h2><p>既然是APK的安装包，那么逆一下去看看加密算法也很合理吧。</p>
<p>在分析之前先看看请求有啥特点，当点击比如”我的账单“的选项的时候，发出去的请求虽然是加密的，但是内容并没有变化，那就可能是对称加密，大概率是ECB模式，没有加盐，没有iv的变化，所以才能明文不变的时候密文也不变。</p>
<p>为了图省事，直接用dex2jar把class文件转成jar，然后用jd_gui来查看。</p>
<p>首先找到与程序包名对应的包，如这里的<code>com.xxx.xxxlife</code>，发现一堆的Activity，一般来说登录和密码找回这两个部分的界面内容是最简单的，这里找到了login的Activity：</p>
<p><img src="/2020/11/07/%E6%A0%A1%E5%9B%AD%E7%94%9F%E6%B4%BBAPP%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95/image-20201107162214893.png" alt="image-20201107162214893"></p>
<p>找这个Activity的目的是看看有没有发送请求的部分，毕竟它在发送之前是要先加密之后再发出去的嘛。</p>
<p>果不其然发现了这个<code>DataUtils.login</code>，这里就是发送登录请求的核心部分。果断单击函数名跟踪过去。</p>
<p>这个函数里面就是简单的对输入参数进行了拼装，合成一个json字符串，然后调用<code>sendRequest</code>函数将参数发送出去。那么这个<code>sendRequest</code>函数里面一定暗藏玄机。</p>
<p><img src="/2020/11/07/%E6%A0%A1%E5%9B%AD%E7%94%9F%E6%B4%BBAPP%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95/image-20201107162530278.png" alt="image-20201107162530278"></p>
<p>果不其然，在构建POST请求的时候，对其中的参数部分进行了加密处理，调用了<code>DES.encryptDES</code>函数。继续跟踪：</p>
<p><img src="/2020/11/07/%E6%A0%A1%E5%9B%AD%E7%94%9F%E6%B4%BBAPP%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95/image-20201107162704233.png" alt="image-20201107162704233"></p>
<p>这里简直毫无悬念，密钥、iv全部暴露出来，使用DES CBC的加密方式，5Padding的填充。</p>
<p>这样一来，通信的加解密就算全搞定了，再回去看看登录的部分，没有Cookie，没有Session，全靠数据里面的UserID……咦？？是不是说我去修改一下Shared_Perference里的数据就可以……花别人的钱了？？？</p>
<h2 id="用Python验证一下"><a href="#用Python验证一下" class="headerlink" title="用Python验证一下"></a>用Python验证一下</h2><p>对于这个加解密，尝试用Python验证一下。这里我用的是Python3环境（毕竟2.x已经被放弃了呢），pyDes的库。这里因为数据都是JSON格式进行封装，然后再加密，再Base64，所以代码也尝试加了JSON的格式化等，来适应这个系统的数据传输。</p>
<p><img src="/2020/11/07/%E6%A0%A1%E5%9B%AD%E7%94%9F%E6%B4%BBAPP%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95/image-20201107163517509.png" alt="image-20201107163517509"></p>
<p>加了控制选项，这样可以更方便的控制是否需要编码/解码。效果如下：</p>
<p><img src="/2020/11/07/%E6%A0%A1%E5%9B%AD%E7%94%9F%E6%B4%BBAPP%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95/image-20201107163638469.png" alt="image-20201107163638469"></p>
<p>成功解密~</p>
<p>如果只是想看看数据，可以用Frida/Objection来Hook加解密函数，可能会更方便，配合脚本什么的还能直接调用sendRequest函数，应该会更爽，不过这里懒得折腾就没进一步去搞了。</p>
<h2 id="手贱的”更进一步“"><a href="#手贱的”更进一步“" class="headerlink" title="手贱的”更进一步“"></a>手贱的”更进一步“</h2><p>到这里本来不想搞了，结果忽然想到”要不要试一下SQL注入呢“。</p>
<p>上面那个解出来的请求是请求用户信息（accountinfo），下面的userid是当前用户的id，一串纯数字。第一个想到就是有没有数字型的注入，于是输入了<code>or 1=1</code>，结果，返回了一个巨大的Response：</p>
<p><img src="/2020/11/07/%E6%A0%A1%E5%9B%AD%E7%94%9F%E6%B4%BBAPP%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95/image-20201107164222145.png" alt="image-20201107164222145"></p>
<p>好吧，我觉得我好像成功了？</p>
<p>每次用脚本加密、再解密数据实在不方便，于是就在上面的Python代码的基础上加了个<code>Requests</code>库，将用户输入的内容自动加密POST发出去，再解密接收到的数据……</p>
<p>先通过<code>order by 1</code>这样的语句确定当前返回值一共有几列，然后就常规的<code>union select</code>带出数据：</p>
<p><img src="/2020/11/07/%E6%A0%A1%E5%9B%AD%E7%94%9F%E6%B4%BBAPP%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95/image-20201107164520544.png" alt="image-20201107164520544"></p>
<p>从结果中可以看出是一个SQLSERVER 2008的数据库：</p>
<p><img src="/2020/11/07/%E6%A0%A1%E5%9B%AD%E7%94%9F%E6%B4%BBAPP%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95/image-20201107164604246.png" alt="image-20201107164604246"></p>
<p>发现SQLServer的数据库平时遇到的太少了，基本都是MySQL的多，而且想想作为探索来说这么多已经远远超过开始想做的事情了，就不再继续搞下去了吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过简单的对这个APP进行了一波分析，发现了一些问题：</p>
<p>1、密钥信息硬编码</p>
<p>2、服务端没有有效的身份校验（缺少Cookie等身份验证机制）</p>
<p>3、存在水平越权（修改userid可以查看其他人的信息）</p>
<p>4、服务端存在SQL注入</p>
<p>5、可能存在反序列化的问题（毕竟是JSON数据，这个部分没有验证）</p>
<p>最后，虽然是校园内部使用的APP，安全性也非常重要，如果被不坏好意的人利用了，不仅仅是我们这些学生的信息遭受损失，系统里的充值信息甚至金钱可能都会遭受损失。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>被伪装成“知识付费”的盗版网站坑了钱之后……</title>
    <url>/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<p>最近迷上了评书，听了一个片段之后很想找到全集把故事听完，于是在网上搜索。找到了一个貌似资源很全的网站，但是“知识付费”时代，必须充会员才能获取真实的下载地址。由于找了很久都没找到这段评书的资源，于是也没多想，充了12元买了这个资源。</p>
<a id="more"></a>

<p>但是充完之后发现想要的资源下载链接是一个百度云，资源已经失效了，于是想找找反馈的入口。结果仔细一看才发现，这个网站非常不正规，虽然是通过QQ登录，但是一般网站会有独立的账号体系，而这个网站不能修改用户的信息，看起来就像是没完工的测试项目似的。</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806160535564.png" alt="image-20200806160535564"></p>
<p>而且网站中的资源非常博杂，从相声戏曲，到新媒体运营，再到编程、软件，简直应有尽有，而且全是百度云的资源，看起来像是收集的盗版的东西。大部分的资源页面包括首页推荐的热门资源中都没有任何留言，就像一幢豪华CBD大厦里面空无一人，显得异常诡异。</p>
<p>查看页面的过程中，只看到了一个站长的联系QQ，加过之后也没反应。那既然这样，还是靠自己一探究竟吧。</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>俗话说知己知彼，百战不殆。在正式开始之前先收集一下目标站点的信息。不同于正规的渗透测试，目标就是这个网站，因此就从服务器IP、开放端口、域名、接口这些信息下手。</p>
<h3 id="域名信息"><a href="#域名信息" class="headerlink" title="域名信息"></a>域名信息</h3><p>首先通过域名，反查它的IP地址以及子域名信息。这里子域名查询没有啥结果，也和预想的差不多，一个坑钱的小网站应该也不会有什么其他子域。</p>
<p>这里用了Chrome的插件 hacker target 来进行简单查询：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806163057871.png" alt="image-20200806163057871"></p>
<h3 id="端口信息"><a href="#端口信息" class="headerlink" title="端口信息"></a>端口信息</h3><p>拿到了IP地址，利用shodan初步看看开放了什么端口：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806162913629.png" alt="image-20200806162913629"></p>
<p>好家伙，有22还有3306？不过shodan向来都不太准，再用其他的工具确认一下。</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806163328543.png" alt="image-20200806163328543"></p>
<p>这回发现多了个21，却没有3306了。那最后再用本机的nmap确认一下端口。</p>
<p>因为直接跑nmap 65535个端口时间太长，而且很容易被云厂商认为是扫描行为而封禁IP，所以可以用这种外围打探的方式先确定基本的端口，最后再用nmap指定端口来确定是否真的开放了。</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806164804389.png" alt="image-20200806164804389"></p>
<p>那么目前能确定的开放端口就是这些。</p>
<h3 id="组件信息"><a href="#组件信息" class="headerlink" title="组件信息"></a>组件信息</h3><p>对于开放的端口，简单识别一下，其中<code>21 - FTP</code>, <code>22 - SSH</code>, <code>80,443 - HTTP(S)</code>, <code>3306 - MySQL</code>，那剩下的8888是什么？访问一下界面，从内容看应该是宝塔面板的登录接口，但是做了相应的安全设置。</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806200632061.png" alt="image-20200806200632061"></p>
<p>回到HTTP(S)服务上来，先尝试用在线CMS识别，发现无法识别出使用的CMS，只知道用的是PHP：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806201506225.png" alt="image-20200806201506225"></p>
<p>再看robots.txt文件，也没什么发现：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806201628384.png" alt="image-20200806201628384"></p>
<p>那么目前判断很有可能就是自己开发的系统。而2020年用PHP开发系统，至少是基于某个框架的，因此寻找一下有没有使用框架的蛛丝马迹。很快，在未登录状态下点击发帖按钮有个登录跳转（这部分在下文详细说如何发现的）：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806201941920.png" alt="image-20200806201941920"></p>
<p>咦？这熟悉的 :( 很想是thinkphp呀！</p>
<p>至此，简单的目标信息收集就结束了，总结如下：</p>
<p>目标域名：<a href="http://www.xxx.net/">www.xxx.net</a></p>
<p>子域名：无</p>
<p>目标IP：3x.xx.xx.x1</p>
<p>开放端口：21，22，80，443，3306，8888</p>
<p>CMS信息：暂无</p>
<p>使用语言：PHP</p>
<p>使用框架：ThinkPHP（目前版本未知）</p>
<p>部署环境：宝塔Linux面板</p>
<h2 id="威胁建模-漏洞分析"><a href="#威胁建模-漏洞分析" class="headerlink" title="威胁建模/漏洞分析"></a>威胁建模/漏洞分析</h2><p>由于是纯黑盒测试，因此不可能有完整的威胁建模进行漏洞分析，只能根据前期收集的信息结合挖洞的过程来慢慢进行威胁建模的部分，因此这两块是合在一起进行的。</p>
<p>首先根据信息收集的内容，可以知道21和22两个端口大概率是宝塔面板提供的，为了方便用户对网站进行管理。因此这里就不去尝试暴力破解了（印象中宝塔是不允许设置弱密码的），如果Web应用的部分无法突破再考虑端口的暴力破解。同理3306也是这样。</p>
<p>8888端口是宝塔的控制面板，因为安全策略无法直接使用。因此将注意力放在443端口的Web Appication上。</p>
<h3 id="HTML-JS分析"><a href="#HTML-JS分析" class="headerlink" title="HTML/JS分析"></a>HTML/JS分析</h3><p>很多情况下，在HTML源码和JS脚本中可能会隐藏诸多秘密，尤其是在目前前端开发喜欢用VUE.js，网站的页面路径很多都会在JS里暴露。</p>
<p>首先先看首页的HTML源码以及加载的非第三方JS代码。在首页的HTML源码中，发现了一段被注释掉的导航栏代码：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806205311823.png" alt="image-20200806205311823"></p>
<p>试一下<code>/taolun</code>，看看还有没有这个页面：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806205618250.png" alt="image-20200806205618250"></p>
<p>看到这个讨论区，很多都是在吐槽链接失效、资源付费后没用的帖子，难怪要把这个导航栏给注释掉！</p>
<p>在页面右下角有一个发新帖的按钮，由于是未登录状态，因此点击之后弹出跳转登录的错误页面（即信息收集里看到的 :( 的页面），确定目标使用的框架是Thinkphp。</p>
<p>看了其他页面的HTML和JS，没有其他有价值的内容了。</p>
<h3 id="ThinkPHP已知漏洞"><a href="#ThinkPHP已知漏洞" class="headerlink" title="ThinkPHP已知漏洞"></a>ThinkPHP已知漏洞</h3><p>既然确定了框架是TP，那么可以试试已知漏洞，万一有呢~</p>
<p>可以利用<a href="https://github.com/theLSA/tp5-getshell/%E5%B7%A5%E5%85%B7%E6%9D%A5%E6%96%B9%E4%BE%BF%E7%9A%84%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%B5%8B%E3%80%82">https://github.com/theLSA/tp5-getshell/工具来方便的进行检测。</a></p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806211806612.png" alt="image-20200806211806612"></p>
<p>这里显示三个PoC均为404，可能是路由配置与默认有差距。这里可以执行其他的用例，比如_method变量覆盖漏洞（可参考<a href="https://www.cnblogs.com/WindrunnerMax/p/12558256.html">《ThinkPHP5.0 漏洞测试》</a>）：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806212306138.png" alt="image-20200806212306138"></p>
<p>这里成功让系统报错，再次确认确实是TP的框架，版本V5.0.0，以及绝对路径等等，这里就不再详细展示。</p>
<p>测试了其他的已知漏洞，都未能成功触发，此路不通。</p>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>因为用的是TP的框架，因此这里实际上也算是已知漏洞的验证了。因为TP自带防护，而且测试了几个点发现SQL防护应该是打开的，而某些注入是需要特定条件（比如把input变量直接转成数组），因为没有源码，试了几个点都没成功就放弃了&gt;.&lt; …</p>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS在这里其实没太大作用，整个网站都没找到有与后台的联系，比如问题反馈什么的，不确定管理员是否会去查看，不过抱着试一试的心情，开始找输入点。</p>
<p>依然还是在<code>/taolun</code>的页面下，找了个帖子进去，发现可以回帖。本着先试试水的心态，复制了这个帖子的标题进去，发现竟然编辑器支持样式！</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806213651303.png" alt="image-20200806213651303"></p>
<p>那这就说明，很有可能这个接口根本不会对输入进行过滤！</p>
<p>迅速打开XSS平台，将代码复制下来，用Burpsuite拦住消息，在结尾插入代码，搞定！</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806214055993.png" alt="image-20200806214055993"></p>
<p>先试试我自己：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806214330841.png" alt="image-20200806214330841"></p>
<p>成功读到了我的Cookie。</p>
<p>但是因为并没有注意邮件，实际上很快就有人看了这个帖子触发了XSS，但等我看到的时候已经失效了……</p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>因为XSS的成功，我判断目标站点应该是除了框架默认的安全配置之外并没有进行额外的安全加固。在“发新帖”的部分，允许用户在帖子里上传图片：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806215141784.png" alt="image-20200806215141784"></p>
<p>这就给了我机会了。先试试简单的，编辑一个文本文件，内容是</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> phpinfo();</span><br></pre></td></tr></table></figure>

<p>文件名保存成<code>1.jpg</code>。上传的时候用Burp将filename的后缀改成.php：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806222704821.png" alt="image-20200806222704821"></p>
<p>浏览器访问成功：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806222905548.png" alt="image-20200806222905548"></p>
<p>利用这个页面，正好查看一下disable_functions的情况：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806222955099.png" alt="image-20200806222955099"></p>
<p>这里可以看到，应该是宝塔面板的设置，在配置里将所有可能命令执行的函数全部都禁用了，因此上传Webshell也没什么意义，没法用菜刀或者AntSword进行连接。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>上面的步骤试探到文件上传，就已经找到了相应的方法可以进行利用了。本来的想法是通过文件上传进行反弹Shell，进一步提权进行后渗透的步骤，但是这里因为<code>disable_functions</code>卡住，需要绕过。</p>
<p>在实施绕过这个步骤之前，可以考虑先利用一下3306端口。之前发现3306是开放的，目前又可以上传PHP源码，可以写一个读取文件的PHP代码，将TP的database.php读出来，获取到数据库用户名和密码从而进行连接。</p>
<p>同时，为了保证之前的phpinfo页面不被其他人发现，写了一个删除文件功能（如果后面不用了还能把上传的这些PHP都删了）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$dir = @$_POST[<span class="string">&quot;dir&quot;</span>];</span><br><span class="line">$del = @$_POST[<span class="string">&quot;del&quot;</span>];</span><br><span class="line">$read = @$_POST[<span class="string">&quot;read&quot;</span>];</span><br><span class="line">$fname = @$_POST[<span class="string">&quot;file&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>($del <span class="keyword">and</span> $fname)&#123;</span><br><span class="line">    <span class="keyword">echo</span>(unlink($dir.$fname));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>($read <span class="keyword">and</span> $fname)&#123;</span><br><span class="line">    $handler=fopen($dir.$fname, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> fread($handler, filesize($dir.$fname));</span><br><span class="line">    fclose($handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>($dir)&#123;</span><br><span class="line">    $handler=opendir($dir);</span><br><span class="line">    <span class="keyword">while</span>(($filename = readdir($handler)) !== <span class="literal">false</span>)&#123;</span><br><span class="line">        $files[] = $filename;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir($handler);</span><br><span class="line">    <span class="keyword">foreach</span>($files <span class="keyword">as</span> $fn)&#123;</span><br><span class="line">        $mark=<span class="string">&quot; &quot;</span>;<span class="keyword">if</span>(is_dir($dir.$fn)) $mark=<span class="string">&quot;+&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> $mark . $fn . <span class="string">&quot; &quot;</span> . @filesize($dir.$fn) .<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实功能很简单，就是列出目录、读取文件、删除文件。</p>
<h3 id="查看Session文件"><a href="#查看Session文件" class="headerlink" title="查看Session文件"></a>查看Session文件</h3><p>忽然想到，之前XSS累死累活，不就是想搞一个SessionID嘛，这都进来了不就可以直接看了？一般情况下，Session文件是存放在<code>/tmp</code>目录下的，PHP默认是以<code>sess_</code>开头的文件名。</p>
<p>先用之前上传的脚本试一下：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806224057289.png" alt="image-20200806224057289"></p>
<p>Bingo！确实在这里。Response中文件名后面的数字是文件大小，超时的Session文件中的数据会被删除，因此大小是 0 。</p>
<p>那找一个大小不为0的，看看内容：</p>
<p><img src="/2020/08/05/%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E5%9D%91%E4%BA%86%E9%92%B1%E4%B9%8B%E5%90%8E/image-20200806224332843.png" alt="image-20200806224332843"></p>
<h3 id="查看数据库配置"><a href="#查看数据库配置" class="headerlink" title="查看数据库配置"></a>查看数据库配置</h3><p>同理，通过前面phpinfo中的绝对路径，可以构建../来进入<code>application</code>文件夹，读取<code>database.php</code>文件，获取MySQL用户名密码。</p>
<p>考虑到宝塔启动MySQL用的是低权限账户，且数据库中的数据目前并没有什么用，还可能又风险，想了想还是不去弄了，反正是个思路。</p>
<h3 id="突破disable-functions"><a href="#突破disable-functions" class="headerlink" title="突破disable_functions"></a>突破disable_functions</h3><p>没有命令执行的WebShell是没有太大的利用价值的，这里想突破一下disable_functions。</p>
<p>突破的方法有很多，大致总结如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>PHP版本</th>
<th>条件</th>
</tr>
</thead>
<tbody><tr>
<td>寻找未禁用函数</td>
<td>任意</td>
<td>disable_functions中没有禁用某些函数</td>
</tr>
<tr>
<td>LD_PRELOAD劫持</td>
<td>任意</td>
<td>Linux环境，putenv()、mail()函数可用</td>
</tr>
<tr>
<td>ShellShock绕过</td>
<td>5.*</td>
<td>目标OS有CVE-2014-6271，Linux环境，putenv()、mail()函数可用</td>
</tr>
<tr>
<td>imap_open任意命令执行</td>
<td>任意</td>
<td>开启imap扩展，并支持imap_open()函数</td>
</tr>
<tr>
<td>Apache+mod_cgi+.htaccess绕过</td>
<td>任意</td>
<td>Apache，启用mod-cgi，允许.htaccess且文件可写</td>
</tr>
<tr>
<td>ImageMagick漏洞绕过</td>
<td>&gt;=5.4</td>
<td>开启ImageMagick插件且插件版本&lt;= 3.3.0</td>
</tr>
<tr>
<td>FFI外部函数接口绕过</td>
<td>7.4</td>
<td>ffi.enable=true</td>
</tr>
</tbody></table>
<p>从目标环境来看，disable_functions已经禁用全部可能利用的函数，导致不满足全部的利用条件。</p>
]]></content>
      <tags>
        <tag>Burpsuite</tag>
        <tag>SQLMap</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>Bluetooth Low Energy(BtLE)攻击方式简述</title>
    <url>/2019/06/19/Bluetooth-Low-Energy-BtLE-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<p>最近收集了一些蓝牙方面存在的漏洞和攻击方式，本文简单的对收集到的资料进行一些整理和一些自己的理解和解释。其中整体方向是偏IoT设备的蓝牙安全。</p>
<p>因为有部分是个人的理解，一些内容可能有错误。</p>
<p>本文中的大部分内容都来自于DEFCON、Blackhat等安全类会议或者活动，且根据我查到的内容来看，蓝牙安全的内容发表时间集中在2013 至 2016，但是目前来说，由于蓝牙协议本身没有大的变化，协议本身也没有过多关注安全方面；而且IoT产品来说也都是各厂商实现自己的安全加固方案，因此虽然时间过去很久，但是这些攻击方式仍然具有参考价值。</p>
<a id="more"></a>

<h1 id="蓝牙通信简介"><a href="#蓝牙通信简介" class="headerlink" title="蓝牙通信简介"></a>蓝牙通信简介</h1><p>首先简单描述一下蓝牙通信的大致情况。由于我这次整理的重点偏流程和逻辑上的漏洞或威胁，因此对于协议底层（物理层，跳频等）不做过多的描述。</p>
<h2 id="蓝牙协议"><a href="#蓝牙协议" class="headerlink" title="蓝牙协议"></a>蓝牙协议</h2><p>蓝牙协议基本分为两类，BR/EDR 和 LE。</p>
<p><strong>BR/EDR</strong></p>
<p>BR/EDR是Basic Rate / Enhanced Data Rate的缩写，属于蓝牙2.x版本所使用的协议。BR可以提供最高721.2Kbps的传输速率，EDR可以提供2.1Mbps的速率。</p>
<p><strong>LE</strong></p>
<p>LE 是 Low Energy的缩写，指的是低功耗蓝牙，蓝牙4.0+版本支持。其设计目的是更低的功耗，更低的复杂度，因此更适用于IoT场景。目前在智能家居、可穿戴设备领域广泛使用的蓝牙通信都是BtLE (Bluetooth Low Energy)。</p>
<p>两个协议的共同点是L2CAP层是相同的，底层（物理层、链路层）都使用不同的协议，而高层（类似于TCP/IP的应用层）各自协议有自己的定义。</p>
<p><img src="/2019/06/19/Bluetooth-Low-Energy-BtLE-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/1.png" alt="协议兼容性示意图"></p>
<p>目前来说大部分设备，尤其是IoT设备使用的都是LE，因此下面的内容也都是基于BLE的内容进行描述和整理，关于BR/EDR这种方式就不再描述。</p>
<h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p>BLE的拓扑结构属于星型结构，设备存在主从关系。主设备管理连接，可连接多台从设备；一个从设备只能连接一台主设备。</p>
<p>因此，在BLE设备上会有六中状态：</p>
<ul>
<li><p><code>Standby</code>待机状态。设备不接受/发送数据，也没有连接到任何设备；</p>
</li>
<li><p><code>Advertiser</code>广播装填，周期性的进行广播；</p>
</li>
<li><p><code>Scanner</code>扫描状态，主动搜寻Advertiser；</p>
</li>
<li><p><code>Initiator</code>发起连接状态，主动向某设备发起连接；</p>
</li>
<li><p><code>Master</code>主设备；</p>
</li>
<li><p><code>Slave</code>从设备。</p>
</li>
</ul>
<h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><p>由于BLE有主从设备之分，因此两台设备连接的时候过程会略有区别。</p>
<p>主设备： <code>Standby</code> -&gt; <code>Scanner</code> -&gt; <code>Initiator</code> -&gt; <code>Master</code></p>
<p>从设备： <code>Standby</code> -&gt; <code>Advertiser</code> -&gt; <code>Slave</code></p>
<ol>
<li><p><code>从设备</code>发起广播包</p>
</li>
<li><p><code>主设备</code>发起扫描事件，监听广播包</p>
</li>
<li><p><code>主设备</code>收到广播包，发出请求建立连接</p>
</li>
<li><p><code>从设备</code>接收到连接请求，建立连接。（发起连接方是<code>Master</code>，接受方是<code>Slave</code>）</p>
</li>
</ol>
<h2 id="HCI简述"><a href="#HCI简述" class="headerlink" title="HCI简述"></a>HCI简述</h2><p>HCI (Host Controller Interface)提供了一个统一的蓝牙控制器方法，提供了同意的数据进入基带的方法，因此应用程序（Profile）无需知道基带的实现。</p>
<p>上文叙述了BR/EDR 和 LE 的区别，对于应用程序/操作系统来说，它们并不关心底层协议，因此HCI中，Controller对接蓝牙基带，Host对接上层，因此HCI是将底层数据提交上来转换成统一的结构为上层提供服务。</p>
<p>在抓包的过程中，能看到很多<code>host</code>和<code>controller</code>之间的数据交互，这部分实际上是在蓝牙协议栈内部完成的，与TCP/IP的形式有所区别。</p>
<div class="tip">
这个部分的叙述是我在查看Wireshark数据包的时候对蓝牙不同的数据包很混淆，实际上LE的数据交互可以从HCI的数据包开始看起，因为设备发起连接是<code>HCI Command</code>的数据包
</div>

<p>下图是Wireshark中解析出的蓝牙数据包（使用安卓系统抓包）</p>
<p><img src="/2019/06/19/Bluetooth-Low-Energy-BtLE-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/2.png" alt="Wireshark中的蓝牙HCI Command数据包"></p>
<p>HCI数据包的格式定义，以<code>Kali Linux</code>为例，存放在<code>/usr/include/bluetooth/hci.h</code>文件中。使用编辑器打开该文件可以看到相关定义。</p>
<h3 id="HCI-Command-和-HCI-Event"><a href="#HCI-Command-和-HCI-Event" class="headerlink" title="HCI Command 和 HCI Event"></a>HCI Command 和 HCI Event</h3><p>HCI分为<code>Command</code>和<code>Event</code>两种数据，<em>个人理解是从Host到Controller的数据都是Command, Controller到Host的都是Event</em> 。</p>
<p>简单画了一张HCI Command协议的结构图：</p>
<p><img src="/2019/06/19/Bluetooth-Low-Energy-BtLE-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/2019-06-19_151521.png" alt="HCI Command协议结构图解"></p>
<p>其中OpCode部分由两段组成，OCF和OGF，表示这个Command所要执行的内容。好在Wireshark中会帮我们将这些数据全部都解析出来，也就不需要手动去拆分了。</p>
<p>HCI Event也是类似的结构，具体的定义可以查看<code>hci.h</code>文件中的详细定义，不再赘述。</p>
<p><img src="/2019/06/19/Bluetooth-Low-Energy-BtLE-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/2019-06-19_152537.png" alt="HCI Event协议结构图解"></p>
<h2 id="GATT简述"><a href="#GATT简述" class="headerlink" title="GATT简述"></a>GATT简述</h2><p>GATT可以理解成TCP/IP的应用层，提供给操作系统与蓝牙模块交互的接口。其协议的层次结构大致如下：</p>
<p><img src="/2019/06/19/Bluetooth-Low-Energy-BtLE-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/2019-06-20_171312.png" alt="蓝牙协议层次示意图"></p>
<h3 id="Services和Characteristics"><a href="#Services和Characteristics" class="headerlink" title="Services和Characteristics"></a>Services和Characteristics</h3><p>在蓝牙通信中，有一个和TCP/IP中<code>端口</code>类似的概念：Services和Characteristics。</p>
<p>一个设备对外会提供多个Services，而每个Service都可能有多个Characteristics。这些都有对应的UUID，因此在通信的时候需要指定要通信的对方的Service UUID，以及Characteristic UUID。</p>
<p>举个例子解释一下他们的关系：蓝牙通信需要目的地址，好比去一栋大楼里找房间，Services相当于单元号，而Characteristics相当于门牌号。指定了X单元Y号就能唯一指定一个房间。</p>
<p>使用工具查看某蓝牙设备的信息如下：</p>
<p><img src="/2019/06/19/Bluetooth-Low-Energy-BtLE-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/3.png" alt="Services &amp; Characteristics"></p>
<p>可以看到，除了圈出的部分，其他都是有文字描述的。蓝牙协议中，官方预留了一些UUID分配给已知的业务，类似于TCP/IP中1 - 1024的端口的分配，具体对应关系可以去查看官方的资料，有详细的说明。</p>
<h1 id="蓝牙安全简述"><a href="#蓝牙安全简述" class="headerlink" title="蓝牙安全简述"></a>蓝牙安全简述</h1><p>上文中叙述了蓝牙协议的基本信息，大致的分类、协议的交互等。下面将针对BLE进行安全方面的分析和阐述，列举出蓝牙可能存在的安全方面的问题。</p>
<h2 id="蓝牙协议规范中的安全加固"><a href="#蓝牙协议规范中的安全加固" class="headerlink" title="蓝牙协议规范中的安全加固"></a>蓝牙协议规范中的安全加固</h2><p>首先先了解一下在蓝牙的协议规范中是如何保证设备连接安全的。</p>
<p>根据<a href="https://developer.bluetooth.org/TechnologyOverview/Pages/LE-Security.aspx">Bluetooth Smart Security</a>中的描述，低功耗蓝牙（BLE）：</p>
<blockquote>
provides several features to cover the encryption, trust, data integrity and privacy of the user’s data
<br>
(提供了多个特性，包括<code>加密</code>、<code>信任</code>、<code>数据完整性</code>和<code>用户数据隐私性</code>)
</blockquote>

<p>协议中提供的安全性如下：</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>在两台设备借助蓝牙协议传输数据之前，双方需要完成<code>配对</code>流程。在<code>配对</code>过程中，双方设备通过密钥生成算法生成并交换了的“长效密钥 <code>LTK</code>(Long Term Key)”，作为链路加密的密钥使用。<code>配对</code>流程中可用的模式有：</p>
<ul>
<li><p>JUST WORK</p>
</li>
<li><p>Passkey Entry（密钥输入）</p>
</li>
<li><p>Out Of Band</p>
</li>
</ul>
<p><code>Passkey Entry</code>密钥输入是和老的蓝牙设备（蓝牙2.x）类似的方式，如果<code>从设备</code>有键盘，则需要在键盘上输入一个和<code>主设备</code>相同的密钥，来完成配对和<code>LTK</code>的生成。这个密码被称为<code>PIN码</code>，一般为6位数字。容易存在暴利破解的风险</p>
<p><code>JUST WORK</code>属于在LE中非常常见的模式，实际上是将<code>Passkey Entry</code>中的输入密钥直接置为’000000‘，从而完成配对和连接的过程。这种方式连接速度快，更适用于IoT领域对连接延时的要求，缺点是<code>PIN码</code>固定，这样就失去了蓝牙原生提供的链路加密的能力，因此如果有敏感数据且没经过有效的加密处理，会造成信息泄露。</p>
<p><code>Out Of Band</code>这种模式很少见，指的是配对信息不通过蓝牙这个信道传输，而是通过NFC等其他手段传输。</p>
<div class="tip">
对于信道加密的实际情况是，大部分的IoT设备都选择了不使用蓝牙协议本身提供的信道加密，而是为了适配各自的服务，在GATT层（蓝牙的应用层）部署自己的加密逻辑，来实现自定义的安全机制。
</div>

<h3 id="MAC地址随机化"><a href="#MAC地址随机化" class="headerlink" title="MAC地址随机化"></a>MAC地址随机化</h3><p>这个似乎也是官方提供的机制（没有实际确认过，不是很确定），会定期随机的改变设备自身的MAC地址；真实的MAC地址仅允许配对过的设备查看。</p>
<h3 id="白名单机制"><a href="#白名单机制" class="headerlink" title="白名单机制"></a>白名单机制</h3><p>这个似乎也是官方提供的，允许设置MAC地址白名单，仅允许白名单中的MAC地址的设备连接。</p>
<h2 id="蓝牙中可能的攻击方式"><a href="#蓝牙中可能的攻击方式" class="headerlink" title="蓝牙中可能的攻击方式"></a>蓝牙中可能的攻击方式</h2><h3 id="针对广播帧-Advertisement-的欺骗攻击"><a href="#针对广播帧-Advertisement-的欺骗攻击" class="headerlink" title="针对广播帧(Advertisement)的欺骗攻击"></a>针对广播帧(Advertisement)的欺骗攻击</h3><p>蓝牙的广播机制在上面已经简单描述过，因为配对的时候需要根据接受到的广播帧(Advertisement)中的数据确定对端设备的MAC地址、设备名等数据，同时有些设备会通过广播帧传输一些数据，或进行信号的监控（<em>这部分不是很确定，目前我并没接触到过通过广播帧传输数据的设备</em>）。因此广播帧可以用来进行欺骗等攻击。</p>
<p>IoT设备大部分使用电池工作，因此设计的时候都会尽量降低功耗，广播的频率会比较低。因此针对广播帧传输数据的场景下，攻击者可以通过比正常发送频率高很多的频率（通常攻击者会使用能达到的最高频率）来发送伪造的恶意广播帧，来达到欺骗(Spoofing)或者干扰(Jamming)的目的。</p>
<p>操纵广播帧的攻击场景如下：</p>
<ol>
<li><p>智能家居中的拒绝服务攻击</p>
<p>这里是有两个攻击场景的。第一是“无脑”的拒绝服务，通过广播一个和真实设备一模一样的广播包，欺骗蓝牙网关/智能手机，让其他设备一直尝试与恶意设备连接（在蓝牙网关/智能手机视角里的“恶意设备”实际上就是一个普通设备而已）</p>
<p>第二个场景，是智能家居的传感器设备通过蓝牙广播的方式发送一些通知数据。此时攻击者可以制作，甚至是重放某些通知数据包。比如某设备会定时广播自己的运行状态，攻击者模拟这个运行状态包，以超高频率广播该设备关机的广播，导致用户查看设备状态时发现设备已关机（实际上运行正常）。</p>
</li>
<li><p>距离防盗报警 (Anti-theft proximity)</p>
<p>先解释一下“距离防盗报警”。这个词我没找到好的翻译方法，自己理解的翻译了一下，就是有一种防盗报警的设备，装在你的行李箱上。当行李箱距离手机等设备超过距离，就会触发警报。</p>
<p>攻击者通过模拟报警器发送的数据，可以偷偷移动行李箱而不触发报警，手机设备能持续接收到行李箱在附近的蓝牙广播包，因此仍然以为行李箱是在范围内的。</p>
</li>
<li><p>信标滥用(Beacon Abuse)</p>
<p>这个部分涉及到<code>iBeacon</code>之类的技术，基本上是说可以通过模拟发送某个Beacon的数据，来影响使用信标定位的设备，伪造位置。</p>
</li>
</ol>
<h3 id="被动监听-Passive-Interception"><a href="#被动监听-Passive-Interception" class="headerlink" title="被动监听(Passive Interception)"></a>被动监听(Passive Interception)</h3><p>被动监听是无线通信中必然会出现的一种攻击手段，几乎在2018年之前我所看到的所有的蓝牙安全方面的文章中，被动监听发现密码、数据明文传输的占到80%。</p>
<p>这种攻击方法无需过多说明，使用Ubertooth即可监听到范围内的蓝牙通信数据（类似WiFi适配器的混杂模式）。当有通信处于未加密状态，或者使用”JUST WORK”方式配对，都可以直接看到内容（JUST WORK就是配对码默认’000000’，至于是否真的能监听到，目前还没有试过）</p>
<h3 id="主动监听-Active-Interception"><a href="#主动监听-Active-Interception" class="headerlink" title="主动监听(Active Interception)"></a>主动监听(Active Interception)</h3><p>主动监听的方式也是一个常见的攻击方式，攻击者可以操纵信道中数据进行<code>转发</code>和<code>丢弃</code>，甚至可以对数据进行<code>篡改</code>。这种攻击方式也被称为<code>中间人攻击</code>/<code>MITM</code>(Man In The Middle attack)</p>
<p>中间人攻击的场景大致如下：</p>
<ol>
<li><p>数据操纵(Data Manipulation)</p>
<p>这个应该是最概括性的攻击场景的描述。中间人攻击可以决定某条数据是否转发/丢弃，同时还可以对数据的内容进行修改。对于明文传输，或者已知密钥的对称加密的数据传输的场景下，是可以任意伪造、篡改数据，造成危害。</p>
</li>
<li><p>命令注入(Command Injection)</p>
<p>命令注入是数据操纵的一种特殊情况，<em>个人理解属于业务逻辑问题</em>。其中一个例子就是例如蓝牙锁，开锁的过程需要经历：手机端鉴权 -&gt; 锁返回SID -&gt; 手机端发送开锁指令(携带SID)</p>
<p>在命令注入的攻击场景下，当手机端发送开锁指令时，攻击者选择将该指令修改成其他，如修改认证密码。一旦密码修改成功，攻击者就可以通过新的密码全面接管系统的控制权（Blackhat大会上有人演示过类似的场景）。</p>
</li>
<li><p>重放攻击</p>
<p>实际上重放攻击可以借助被动监听记录数据包再重放出去，但是这里有个有趣的利用方式：比如，某系统没有进行防重放机制，先监听用户的登录认证请求，利用系统回传的SID，加上之前记录的数据，进行数据包的重放，从而破坏系统完整性。</p>
</li>
</ol>
<h3 id="针对暴露服务-Exposed-Services-的攻击"><a href="#针对暴露服务-Exposed-Services-的攻击" class="headerlink" title="针对暴露服务(Exposed Services)的攻击"></a>针对暴露服务(Exposed Services)的攻击</h3><p>上文中简要介绍过了Services的概念。在一般使用过程中，Services和Characteristic是最直接和全面描述一个蓝牙设备能提供能力的途径，而且查询这些属性是无需鉴权和配对的，BLE中，对外暴露的Services是允许任意设备进行查看的。</p>
<ol>
<li><p>任意接口的访问</p>
<p>由于对外暴露的Services允许任意设备查看，因此在不增加额外鉴权和加密的情况下，任意用户都可以对设备提供的数据进行查看，并操纵蓝牙设备。</p>
</li>
<li><p>暴力破解</p>
<p>原生蓝牙协议中没有防止暴力破解的功能，因此在没有<code>软锁定机制(soft-lock)</code>的情况下，存在暴力破解的风险。</p>
</li>
<li><p>不恰当的随机数生成</p>
<p>这个问题不仅在蓝牙通信中存在，实际上是一个广泛的问题。一些没有内建(build-in)随机数生成器的模块，在生成随机数的时候存在<code>伪随机数</code>的情况。因此，在例如“挑战-响应”鉴权(Challange-Response Authentication)中，如果随机数的生成是可预测的，对整个鉴权都会产生影响。</p>
</li>
<li><p>额外服务(Excessive Services)无鉴权访问</p>
<p>设备可能存在额外服务，而这些服务无需鉴权即可访问。</p>
</li>
<li><p>模糊测试(Fuzzing)</p>
<p>通过发送一系列非预期的输入，检查设备是否存在不正常的状态。</p>
</li>
<li><p>业务逻辑漏洞(Logical flaws)</p>
<p>这一项也是比较通用的问题，其实不是蓝牙专属的攻击方式。通过业务逻辑上的错误/失误，对某些操作，比如认证、鉴权等绕过，实现非预期的操作。</p>
</li>
</ol>
<h3 id="针对配对-Pairing-的攻击"><a href="#针对配对-Pairing-的攻击" class="headerlink" title="针对配对(Pairing)的攻击"></a>针对配对(Pairing)的攻击</h3><p>针对配对的攻击，主要的目的是获取设备的“长效密钥（Long Term Key, <code>LTK</code>）”，从而对设备之间传输的数据进行解密、监听。这个攻击方式主要的问题，是蓝牙设备并不检测是否有<code>主动监听</code>或<code>MITM</code>的存在，即使无法连接也不会有安全性提示，导致用户使用过程中很容易在无法连接的时候选择删除配对重连，会连接到攻击者的设备上，从而被监听数据。</p>
<ol>
<li><p>JUST WORK</p>
<p>Just Work因为不需要用户手动输入<code>配对PIN码</code>，因此可以通过设备“克隆“一个设备的信号，进行中间人攻击。</p>
</li>
<li><p>有PIN码保护的配对</p>
<p>通过干扰（Jamming）正常设备的连接过程，迫使用户认为配对出错而删除原有配对并重新配对。攻击者只需要在重新配对的过程中监听配对数据，即可通过被动监听获取交换的密钥，拿到<code>LTK</code>，从而解密后续的所有通信数据。</p>
</li>
</ol>
<p>提供一张Blackhat 2013的Presentation中的一个截图，说明一下配对中密钥破解的原理：</p>
<p><img src="/2019/06/19/Bluetooth-Low-Energy-BtLE-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/2019-06-21_114609.png" alt="密钥破解原理说明"></p>
<p>几种密钥之间的关系：</p>
<p><code>TK</code> -&gt; <code>STK</code> -&gt; <code>LTK</code> -&gt; <code>Session keys</code>或<code>Link key</code></p>
<p><code>TK</code>：Temprarily Key，临时密钥</p>
<p><code>STK</code>：Short Term Key，短期密钥</p>
<p><code>LTK</code>：Long Term Key，长期密钥</p>
<p><code>Link key</code>：或<code>Session key</code>，当前会话的加密密钥</p>
<h3 id="白名单绕过-Whitelisting-Bypass"><a href="#白名单绕过-Whitelisting-Bypass" class="headerlink" title="白名单绕过(Whitelisting Bypass)"></a>白名单绕过(Whitelisting Bypass)</h3><p>由于蓝牙的白名单机制是通过过滤MAC地址完成的，因此攻击者可以伪造一个白名单中的MAC地址来绕过这一机制。</p>
<h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><p>之前接触过一些IoT设备，比如手环类设备、智能门锁等，从目前的产品的实现来看，在连接上都是无需配对，且可用的Services都是暴露的，可以直接向设备发送数据。</p>
<p>比如某手环，使用LightBlue工具可以直接连接，并且向其服务发送数据可以直接生效，但是要先认证。操作该手环需先认证（具体认证步骤不详述，实际操作中只要用APP连接一次手环即可），通过认证后会绑定认证设备的MAC地址。在数分钟内，通过认证的设备可以直接访问Services中的Characteristic向其发送数据。</p>
<p>可穿戴设备、智能家居类产品，为了追求连接速度，一般情况下都是无需配对就可以直接访问并进行数据交互，因此这类产品都是靠自定义认证/加密来保证通信安全。因此<strong>认证的逻辑、加密的算法和强度</strong>会直接影响到通信安全。</p>
<p>但是使用BLE的蓝牙耳机这种设备，比如Sony的某款蓝牙耳机，在首次配对时会生成一个6位随机PIN码发送给手机，使用原生的加密方式来保证传输安全。大致的链接流程如下：</p>
<p><img src="/2019/06/19/Bluetooth-Low-Energy-BtLE-%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/4.png" alt="Sony某款蓝牙耳机配对过程"></p>
<blockquote>
对上图中配对过程的简单分析、解释：
<p>
Frame 393: <code>User Confirmation Request</code><br>

</p><p>对端（在此处是蓝牙耳机）请求确认Numeric Value，本地host在收到后确认。因为之前协商过程中有Automatic Accept Allowed的选项，因此手机端不会弹出确认界面。</p>
<p></p><p>
Frame 394: <code>User Confirmation Request Reply</code><br>
相应前一个数据帧，给对端回应，确认之前发送的Numeric Value是正确的。
</p><p>
Frame 395: <code>Command Complete</code><br>
Controller回应，表明之前host的确认消息成功发送。
</p><p>
Frame 396: <code>Simple Pairing Complete</code><br>
表示配对成功。
</p><p>
Frame 397: <code>Link Key Notification</code><br>
Controller通知host，接下来链路加密用的Link Key是什么
</p><p>
Frame 398: <code>Authentication Complete</code><br>
认证结束
</p>
</blockquote>

<p>这种配对方式中，在手机连接前会生成<code>STK(Short Term Key)</code>，<code>SK(Session Key)</code>等，因此过程会稍长，更适合于长时间、大量数据的传输，而不适合IoT设备中突发性强、连接时间短、数据量小的传输场景<em>（个人观点）</em>。</p>
<p>因此，总结起来，IoT领域中的BLE的特点：</p>
<ul>
<li><p>一般无需配对</p>
</li>
<li><p>有各自制造商设计和实现的认证、加密过程确保安全性</p>
</li>
<li><p>服务都是对外暴露的，允许任意设备调用</p>
</li>
<li><p>大部分没有使用蓝牙原生的信道加密（即如果制造商没有在“应用层“实现加密，就是明文传输）</p>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Filizzola, D., Fraser, S.P., &amp; Samsonau, N. (2018). Security Analysis of Bluetooth Technology.</p>
<p>[2] Jasek, S. (2016). Gattacking Bluetooth smart devices. In <em>Black Hat USA Conference</em>.</p>
<p>[3] Ryan, M. “Bluetooth Smart: The Good, the Bad, the Ugly, and the Fix.” <em>BlackHat USA, Las Vegas, USA</em> (2013).</p>
<p>[4] Ryan, M. (2013). Bluetooth: With low energy comes low security. In <em>Presented as part of the 7th {USENIX} Workshop on Offensive Technologies</em>.</p>
<p>[5] Vainio, J. T. (2000, May). Bluetooth security. In <em>Proceedings of Helsinki University of Technology, Telecommunications Software and Multimedia Laboratory, Seminar on Internetworking: Ad Hoc Networking, Spring</em> (Vol. 5).</p>
]]></content>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>Root-me Web-Server WriteUp</title>
    <url>/2019/06/26/Root-me-Web-Server-WriteUp/</url>
    <content><![CDATA[<p>最近在做<a href="https://www.root-me.org/">Root-me</a>的题，顺手记一下相关的题目的解题思路，顺便梳理一下各个知识点。</p>
<p>我是按照Validations从高到低的顺序做的，和我刷LeetCode的习惯保持了一致=。=</p>
<a id="more"></a>

<ol>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/HTML-source-code">HTML - source code</a></p>
<p>这道题不难，右键查看源码即可</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/Weak-password">Weak password</a></p>
<p>祖传老密码，admin/admin 轻松拿到password</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/HTTP-User-agent">HTTP - User-agent</a></p>
<p>题目中已经给出了tips，正常访问会显示 <code>Wrong user-agent: you are not the &quot;admin&quot; browser!</code>，修改HTTP请求的头部<code>User-agent</code>字段，值为<code>admin</code>即可得到password</p>
</li>
<li><p>这一题也不难，查看源码有个<code>include</code>的注释，提示了<code>admin/pass.html</code>，在地址栏里加上admin这个路径，可以看到列出的目录，进入<code>/admin/backup/admin.txt</code>成功读取password</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/Backup-file">Backup file</a></p>
<p>这道题着实卡住了，尝试了各种备份文件的名字和后缀，都没成功。没忍住看了网上的解题思路：</p>
<blockquote>
1. 产生其他扩展名：.zip，.bak，.tar，.gz等
<br>
2. 编辑器生成了临时文件：file~
<br>
3. 老文件：file.old
</blockquote>

<p>所以这题的备份文件是index.php~，输入后得到源码，获取到password。</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/HTTP-Headers">HTTP - Headers</a></p>
<p>依然是题目给了提示，查看Response头，发现有个字段<code>Header-RootMe-Admin</code>，尝试在Request中添加这个头，值任意，发送过去得到password</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/HTTP-Open-redirect">HTTP - Open redirect</a></p>
<p>这题有点意思，点开之后发现是三个跳转的链接，每个链接都是在当前页面的url后面附了参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;?url=https://facebook.com&amp;h=a023cfbf5f1c39bdf8407f28b60cd134&#x27;</span>&gt;</span>facebook<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>尝试修改参数里<code>url</code>那个部分，比如替换成<code>https://baidu.com</code>，访问之后发现仍然是没有加参数的那个页面的内容。后面的参数<code>h</code>引起了注意，看起来很像md5的值，找了个md5生成器验证了下，果然这个参数<code>h</code>是前面<code>url</code>的md5</p>
<p>将<code>url</code>替换成其他，如baidu，算一下md5，结果得到一个完整的链接：</p>
<blockquote>
http://challenge01.root-me.org/web-serveur/ch52/?url=https://baidu.com&h=bb6e082d5c360ce6a0c64f926feea905
</blockquote>
访问，页面显示出flag。
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/PHP-Command-injection">PHP - Command injection</a></p>
<p>很简单的一个PHP命令注入，按照页面的提示输入参数127.0.0.1，会执行Ping这个命令。直接在输入框中输入：<code>127.0.0.1 &amp;&amp; ls -la</code>，发现可以列出当前文件夹里的文件。</p>
<p>首先想到了去看下这个php页面的源码，因此注入：<code>127.0.0.1 &amp;&amp; cat index.php</code>，F12查看HTML代码，发现在<code>&lt;pre&gt;</code>标签中存在一个注释，得到password。</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/Install-files">Install files</a></p>
<p>题目中给出了提示，You know phpBB? 第一感觉这应该是一个CMS，题目又叫做install files，自然想到了去找install.php。</p>
<p>打开题目的页面，F12看一下，发现一个注释：</p>
<blockquote>
<pre>
    &lt!-- /web-serveur/ch6/phpbb -->
</pre>
</blockquote>

<p>果断访问一下，发现首页是空白的。惯例去访问一下install.php，结果404。去掉后缀，访问install目录，居然展示出目录里的文件，看到有install.php。最终的URI是：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/phpbb/install/install.php</span><br></pre></td></tr></table></figure>

<p>访问页面，直接展示出password。</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/HTTP-verb-tampering">HTTP - verb tampering</a></p>
<p>这个漏洞之前没有太关注过，查了下叫做HTTP动词篡改，其实就是HTTP方法（HTTP Method）部分在服务端检查不严格，支持危险的（PUT / DELETE / TRACE / MOVE / COPY / PROPFIND / MKCOL / LOCK / UNLOCK等）方法，或没有对这些支持的方法进行严格的判断，从而造成的越权、文件上传、认证绕过等后果。</p>
<p>因此只需要把访问的method随便换一个就好了，比如：</p>
<p><img src="/2019/06/26/Root-me-Web-Server-WriteUp/2019-06-26_143359.png" alt="Firefox插件发送自定义method的HTTP请求"></p>
<p>返回值中成功拿到password</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/HTTP-cookies">HTTP - cookies</a></p>
<p>打开页面，看到Saved email address这样一个链接，点进去页面刷新，显示<code>You need to be admin</code>。</p>
<p>F12查看页面元素，看到一个注释，<code>SetCookie(&quot;ch7&quot;, &quot;visiteur&quot;)</code>，再去查看浏览器的Cookie，发现有ch7这个键对应visiteur的值。按照提示修改Cookie的值为admin，重新点击Saved email addresses，获得password。</p>
<p>吐槽下，这个地方addresses居然拼错了~</p>
<p><img src="/2019/06/26/Root-me-Web-Server-WriteUp/2019-06-26_145111.png" alt="页面中注释的setcookie"></p>
</li>
<li><p><a href="http://challenge01.root-me.org/web-serveur/ch32/">HTTP - Improper redirect</a></p>
<p>这题点进去访问的页面会返回的Response Headers里有一项叫Location，进行重定向。所以直接查看是看不到东西的，使用Burp抓包，可以看到flag：</p>
<p><img src="/2019/06/26/Root-me-Web-Server-WriteUp/2019-06-28_153956.png" alt="重定向的Response中的内容"></p>
</li>
<li><p><a href="http://challenge01.root-me.org/web-serveur/ch15/ch15.php">Directory traversal</a></p>
<p>这题思路也比较简单，既然提示了路径遍历，那就先随便点一下看看URL的构成，比如选<code>devices</code>这个文件夹，URL是<code>http://challenge01.root-me.org/web-serveur/ch15/ch15.php?galerie=devices</code></p>
<p>替换<code>galerie</code>的值为<code>./</code>，看下当前文件夹下有什么：<img src="/2019/06/26/Root-me-Web-Server-WriteUp/2019-06-28_154519.png" alt="根文件夹列出的内容"> 这里<code>86hwnX2r</code>引起注意，再尝试读这个文件夹，将86hwnX2r拼接到URL后面，又发现了奇怪的东西：<img src="/2019/06/26/Root-me-Web-Server-WriteUp/2019-06-28_154939.png" alt="发现目标文件"> 尝试访问这个文件，得到password。</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/File-upload-double-extensions">File upload - double extensions</a></p>
<p>已经提示了是双重扩展的问题，上传一个后缀为<code>.php.png</code>的文件即可。我用了AntSword进行连接，使用一句话PHP。</p>
<p>连上之后跳转到当前网站的根（ch20这个文件夹），下载<code>.passwd</code>文件，打开即得到password：<img src="/2019/06/26/Root-me-Web-Server-WriteUp/2019-06-28_192534.png" alt="使用AntSword连接"> </p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/CRLF">CRLF</a></p>
<p>这题实际上有点脑洞，不过提示中说，<code>Inject false data in the journalisation log.</code>，就是让我们在下面的log中注入一条成功登录的日志。</p>
<p>看日志打印的情况，应该就是把用户名读进去在打印出来，而且每行显示一条日志。日志的格式是：<code>用户名</code> + failed to authenticate. 这样的话只需要让用户名为<code>admin authenticate.\r\nadmin</code>即可。</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/HTTP-POST">HTTP - POST</a></p>
<p>这题打开点一下按钮，发现是发送一个数据，要求是要超过<code>999999</code>。F12看下network，发现数据是本地POST过去。</p>
<p>再F12 Element查看页面，在form的<code>onsubmit</code>方法里有个随机数，<code>Math.random() * 1000001</code>，修改掉这个值，这里我去掉了前面的<code>Math.random()</code>，这样发送的数据就是<code>1000001</code>。</p>
<p>此时点击Give a try,成功得到了password。<img src="/2019/06/26/Root-me-Web-Server-WriteUp/2019-06-28_194503.png"></p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/File-upload-MIME-type">File upload - MIME type</a></p>
<p>这题就是单纯的在MIME type上进行了限制，将上传数据中的Content-type改成<code>image/png</code>即可。<img src="/2019/06/26/Root-me-Web-Server-WriteUp/2019-06-28_195118.png" alt="burpsuite中修改Content type">  </p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/File-upload-null-byte">File upload - null byte</a></p>
<p>这题的名字有点奇怪，但其实就是<code>%00</code>截断。按照上题，将文件名变成<code>payload.php%00.png</code>，上传后去访问payload.php即可。</p>
<p>这里识别到上传成功后，系统会删除该文件，直接给你返回password</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/PHP-filters">PHP - filter</a></p>
<p>这题是一个php包含的漏洞。进入题目看url中有参数，尝试改一下，报错发现是include了参数。但是这里限制了include路径，不能任意include文件。</p>
<p>因此想看下login.php中是如何验证用户名和密码的，因此目的是要把login.php的源码打出来。</p>
<p>使用php://filter将文件编码成base64在include即可打印出来。<code>php://filter/convert.base64-encode/resource=filepath</code></p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/SQL-injection-string">SQL injection - string</a></p>
<p>这题依然是SQLI，首先思路是找注入点（用单引号去试，比如<code>&#39;1</code>），在<code>search</code>页面中发现注入点。</p>
<p>此时使用<code>union</code>关键字去进行参数的拼接，因为<code>union</code>的时候需要字段数与原SQL语句一致，我使用类似<code>&#39;union select 1,1,1 --</code>的语句，更换1的数量来试出原语句中的字段数。</p>
<p>从报错信息中可以看到它用的是sqlite3，因此思路是去读sqlite3的系统表<code>sqlite_master</code>，先看下数据库里有哪些数据表以及表结构。<code>sqlite_master</code>的结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sqlite_master ( </span><br><span class="line"><span class="keyword">type</span> <span class="built_in">TEXT</span>, </span><br><span class="line"><span class="keyword">name</span> <span class="built_in">TEXT</span>, </span><br><span class="line">tbl_name <span class="built_in">TEXT</span>, </span><br><span class="line">rootpage <span class="built_in">INTEGER</span>, </span><br><span class="line"><span class="keyword">sql</span> <span class="built_in">TEXT</span> </span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>因此第一阶段的payload入下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1&#x27; or 1=1 union <span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">sql</span> <span class="keyword">from</span> sqlite_master <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/06/26/Root-me-Web-Server-WriteUp/2019-07-09_141226.png" alt="SQL注入得到的表信息"></p>
<p>发现了<code>user</code>表以及其字段<code>username</code>, <code>password</code>，这样就可以去构建union语句来读取数据了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1&#x27; or 1=1 union <span class="keyword">select</span> username, <span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="comment">--</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/PHP-register-globals">PHP - register globals</a></p>
<p>Register Globals是PHP的一个特性，在<code>4.2.0</code>版本之前默认开启，<code>5.3.0</code>版本废弃，<code>5.4.0</code>版本彻底移除。简单来说，开启这个特性之后，PHP允许代码中的变量用除了在代码中赋值的方式以外进行初始化（赋值）。</p>
<p>按照官方手册的例子来说，PHP允许从请求中对变量进行初始化，也就是说可以通过在URL中以<code>?key=var</code>的形式来给变量进行赋值，从而改变原本代码的逻辑结构。具体可以参考<a href="https://php.net/manual/zh/security.globals.php">PHP官方手册</a>。</p>
<p>想要利用变量覆盖进行攻击，需要知道具体的代码逻辑和变量名称。题目中给出了提示：<code>It seems that the developper often leaves backup files around...</code>，说明有隐藏的源码。猜一下文件名，<code>index.php.bak</code>，成功下载到备份文件。</p>
<p>看一下代码逻辑，发现其核心语句如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (( <span class="keyword">isset</span> ($password) &amp;&amp; $password!=<span class="string">&quot;&quot;</span> &amp;&amp; auth($password,$hidden_password)==<span class="number">1</span>) || (is_array($_SESSION) &amp;&amp; $_SESSION[<span class="string">&quot;logged&quot;</span>]==<span class="number">1</span> ) )&#123;</span><br><span class="line">    $aff=display(<span class="string">&quot;well done, you can validate with the password : $hidden_password&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $aff=display(<span class="string">&quot;try again&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里有个<code>||</code>，那么只要符合其中之一的条件即可。看后半段的条件，只要<code>$_SESSION[&quot;logged&quot;]</code>的值为<code>1</code>即可，结合上面变量覆盖，构造出<code>index.php?_SESSION[&quot;logged&quot;]=1</code>即可。</p>
<p>尝试之后发现并没有用，考虑可能是双引号被过滤，修改为<code>index.php?_SESSION[logged]=1</code>顺利执行。</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/SQL-injection-numeric">SQL injection - numeric</a></p>
<p>又是一道SQLI的题目，这次的主题是数字型的注入。按照题目的内容来看，注入点应该是在新闻条目的id处。尝试加一个<code>&#39;</code>，成功引发报错。</p>
<p>因为是数字型的注入，因此原语句应该是类似于<code>select xx from xxx where id=1 ...</code>这样的，因此注入的时候使用<code>1 union select 1,1,1 --</code>先试探一下。剩下的内容和上面字符型注入是一样的。</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/PHP-assert">PHP - assert()</a></p>
<p>这题的目的是读取到<code>.passwd</code>这个文件。点开题目，看到url中有<code>?page=about</code>这样的字样，感觉有文件包含。随意改一个名字，比如<code>about1</code>，报错信息提示<code>&#39;includes/about5.php&#39;File does not exist</code>。说明它加载的时候是在输入的文件名后面加了个<code>.php</code>的后缀。</p>
<p>再尝试一下路径遍历，输入<code>../index</code>，得到另一个报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: assert(): Assertion &quot;strpos(&#39;includes&#x2F;..&#x2F;index.php&#39;, &#39;..&#39;) &#x3D;&#x3D;&#x3D; false&quot; failed in &#x2F;challenge&#x2F;web-serveur&#x2F;ch47&#x2F;index.php on line 8</span><br><span class="line">Detected hacking attempt!</span><br></pre></td></tr></table></figure>

<p>这里就可以猜到，assert语句大概应该是：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">assert(<span class="string">&quot;strpos(&#x27;includes/$&#123;input&#125;.php&#x27;, &#x27;..&#x27;) === false&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    $file = <span class="string">&#x27;includes/$&#123;input&#125;.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(exist($file))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正常加载的代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不包含 .. ，但是文件不存在</span></span><br><span class="line">        <span class="keyword">echo</span> $file . <span class="string">&quot; File does not exist&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//输入中包含 .. ，有路径遍历</span></span><br><span class="line">    <span class="keyword">echo</span> $&#123;input&#125; . <span class="string">&quot;Detected hacking attempt!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此尝试用输入将assert里面的语句截断，尝试一下<code>&#39;, &#39;aaa&#39;) || strpos(&#39;</code>，发现回显是说 File does not exist，说明已经成功闭合了assert里面的字符串，说明这里是可以进行注入的。</p>
<p>尝试一下打印<code>phpinfo</code>：<code>&#39;, &#39;aaa&#39;) ||phpinfo()|| strpos(&#39;</code>，成功。</p>
<p>那直接打印<code>.passwd</code>文件即可，<code>&#39;, &#39;aaa&#39;) ||var_dump(file_get_contents(&#39;.passwd&#39;))|| strpos(&#39;</code>。这里不能使用<code>echo</code>，因为它没有返回值，因此<code>var_dump</code>或者<code>print_r</code>都可以。</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/Local-File-Inclusion-Double-encoding">Local File Inclusion - Double encoding</a></p>
<p>这道题和php - filter那题类似，目标是读取源码，<code>include</code>语句包含了在URL中的参数。</p>
<p>第一个想法是构造一个filter语句，去读取页面的base64编码后的源码：<code>?page=php://filter/convert.base64-encode/resource=home</code>。直接输入，页面返回：<code>Attack detected.</code></p>
<p>此时想到题目给出的提示，进行URL编码，两次编码，实际上第二次编码只是把<code>%</code>编码成<code>%25</code>。</p>
<p>再次发送两次编码的payload，依然提示<code>Attack detected.</code></p>
<p>思考一下，发现在payload中的<code>convert.base64-encode</code>中有个<code>.</code>，一般情况下URL编码默认是不会对这个符号进行编码，手动编码，把 点 替换成<code>%252e</code>，执行成功。</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/Remote-File-Inclusion">Remote File Inclusion</a></p>
<p>本题的目的是读取<code>index.php</code>的源码。</p>
<p>首先进入页面，看到切换语言的时候url发生了变化，<code>?lang=en</code>参数控制语言的类型。尝试修改一下这个值，比如变成<code>?lang=en1</code>，会有错误提示，可以看出这里是用了<code>include(&#39;$&#123;input&#125;_lang.php&#39;)</code>这样的语句进行include的。</p>
<p>尝试去include<code>index.php</code>，发现include的目录被限制在<code>.:/usr/share/php</code>，没法猜出来<code>index.php</code>的路径。这里虽然是补了后缀，但是可以用<code>%00</code>截断的方式来屏蔽后面的部分，比如<code>?lang=index.php%00</code>。</p>
<p>尝试用<code>php://filter</code>的方式去加载<code>en_lang.php</code>，里面没有什么重要的内容。那么LFI应该是不能达到目的了。</p>
<p>尝试RFI，将参数写成一个远程地址，比如<code>https://www.baidu.com</code>，但是注意在include语句中后面还有个<code>_lang.php</code>，所以这里需要构造参数为<code>?lang=https://www.baidu.com?</code>，来把后面的部分作为参数，访问后打开了百度的页面。</p>
<p><img src="/2019/06/26/Root-me-Web-Server-WriteUp/2019-07-09_192154.png" alt="RFI打开的baidu页面"></p>
<p>到了这一步就已经很明显了，只要找一个页面内容为<code>&lt;?php echo file_get_contents(&#39;index.php&#39;);?&gt;</code>的远程页面，将url填在参数部分即可。</p>
</li>
<li><p><a href="https://www.root-me.org/en/Challenges/Web-Server/Java-Server-side-Template-Injection">Java - Server-side Template Injection</a> </p>
<p>这个问题是由于服务端对输入没有进行合理过滤导致用户输入作为模板执行。</p>
<p>首先就是要确定用的是什么模板，Burpsuite官方，PortSwigger有篇博文描述了一种简单的检测方法：<a href="https://portswigger.net/blog/server-side-template-injection">Server-Side Template Injection</a>，部分截图如下：</p>
<p><img src="/2019/06/26/Root-me-Web-Server-WriteUp/2019-07-09_194016.png" alt="Burpsuite博客中给出的"></p>
<p>然而根据这张表的内容似乎没法判断这题用的模板。但是，当我输入到<code>$&#123;&quot;z&quot;.join(&quot;ab&quot;)&#125;</code>用例的时候，引发了模板报错，页面上显示的是<code>An error occurs!</code>，赶紧打开F12 - Network，看下网络交互，发现返回值是<code>500</code>，内容里有一句<code>exception: &quot;freemarker.core.ParseException&quot;</code>，查了下<code>freemarker</code>就是一个Java的模板。</p>
<p>确定了模板，就可以利用模板构建payload了。</p>
<p>Baidu一下：<code>freemarker 执行系统命令</code>，</p>
</li>
</ol>
<ol start="27">
<li></li>
</ol>
]]></content>
      <tags>
        <tag>web安全</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>WPA四次握手过程解析</title>
    <url>/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>最近在梳理Wi-Fi的攻击方式，又看到了17年的KRACK漏洞。当时只是看了漏洞的原理和危害，并没有理解漏洞的成因和为什么被利用。本文尝试结合Python代码来理解一下WPA四次握手的过程，以及尝试分析一下KRACK漏洞。</p>
<a id="more"></a>

<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>在正式开始分析之前，先要准备一下软件和分析对象。</p>
<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p>本次使用的操作系统是Windows10 1909，部分需要Linux的使用虚拟机安装的Kali进行。</p>
<p>代码部分，解释器版本为Python 2.7。</p>
<p>数据包分析工具使用经典的Wireshark。</p>
<h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>由于不同的加密方法和参数对握手包的影响较大，因此分析对象使用了Wireshark官方给出的WPA数据包。</p>
<p>该数据包可以在<a href="https://wiki.wireshark.org/HowToDecrypt802.11%E9%A1%B5%E9%9D%A2%E4%B8%8A%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%EF%BC%9A">https://wiki.wireshark.org/HowToDecrypt802.11页面上进行下载：</a></p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200629105537200.png" alt="image-20200629105537200"></p>
<p>额外说明一下，如果想自己捕获设备的WPA握手包，则需要额外的软件，并将网卡置为<code>Monitor Mode</code>。下面简单介绍一下。</p>
<h2 id="手动捕获握手包"><a href="#手动捕获握手包" class="headerlink" title="手动捕获握手包"></a>手动捕获握手包</h2><p><strong>Windows平台</strong>：在Windows平台下想要捕获802.11管理帧，需要使用微软官方的软件<a href="https://www.microsoft.com/en-us/download/details.aspx?id=4865">Microsoft Network Monitor</a>。它的安装和使用也相对比较方便，网上也有相当多的教程，如《<a href="https://cstriker1407.info/blog/windows-80211-frame/">windows下抓取802.11管理包</a>》。有一点需要注意，该软件在“扫描设置（Scanning Options）”中开启<code>Monitor Mode</code>后，该窗口不能关闭，否则会退出：</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/20150905181951_10373.png" alt="img"></p>
<p><strong>Linux平台</strong>：在Linux平台下，可以借助我们熟悉的<code>aircrack-ng</code>套件来设置网卡的<code>Monitor Mode</code>，并使用<code>Wireshrak</code>来获取和查看数据。此处以Kali为例，其他Linux系统可以自行安装相关套件。</p>
<p>设置监听模式的命令为：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@kali:~<span class="comment"># airmon-ng start wlan0</span></span><br></pre></td></tr></table></figure>

<p>其中<code>wlan0</code>是网卡的名称。若出现以下情况：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@kali:~<span class="comment"># airmon-ng start wlan0</span></span><br><span class="line"></span><br><span class="line">Found <span class="number">2</span> processes that could cause trouble.</span><br><span class="line"><span class="keyword">If</span> airodump<span class="literal">-ng</span>, aireplay<span class="literal">-ng</span> or airtun<span class="literal">-ng</span> stops working after</span><br><span class="line">a short period of time, you may want to run <span class="string">&#x27;airmon-ng check kill&#x27;</span></span><br><span class="line"></span><br><span class="line">    PID Name</span><br><span class="line">   <span class="number">1959</span> NetworkManager</span><br><span class="line">   <span class="number">1989</span> wpa_supplicant</span><br><span class="line"></span><br><span class="line">PHY    Interface    Driver        Chipset</span><br><span class="line"></span><br><span class="line">phy0    wlan0        rt2800usb    Ralink Technology, Corp. RT2870/RT3070</span><br><span class="line"></span><br><span class="line">        (mac80211 monitor mode vif enabled <span class="keyword">for</span> [<span class="type">phy0</span>]wlan0 on [<span class="type">phy0</span>]wlan0mon)</span><br><span class="line">        (mac80211 station mode vif disabled <span class="keyword">for</span> [<span class="type">phy0</span>]wlan0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明网卡被占用，需要使用<code>airmon-ng check kill</code>命令来结束占用进程：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@kali:~<span class="comment"># airmon-ng check kill</span></span><br><span class="line"></span><br><span class="line">Killing these processes:</span><br><span class="line"></span><br><span class="line">    PID Name</span><br><span class="line">   <span class="number">1989</span> wpa_supplicant</span><br><span class="line"></span><br><span class="line">root@kali:~<span class="comment"># airmon-ng start wlan0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PHY    Interface    Driver        Chipset</span><br><span class="line"></span><br><span class="line">phy0    wlan0mon    rt2800usb    Ralink Technology, Corp. RT2870/RT3070</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里网卡名称会变成<code>wlan0mon</code>，需要注意。</p>
<p>但是，直接设置后抓包有时只能抓到部分，比如仅有AP侧的数据，设备端的数据包都丢失了，原因是<strong>未指定信道</strong>。此时需要使用<code>airodump-ng</code>工具查看目标AP的信道：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@kali:~<span class="comment"># airodump-ng wlan0mon</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200629141915808.png" alt="image-20200629141915808"></p>
<p>上图中第一行所示的信息中，CH表示信道，我们想对该AP进行四次握手的捕获，则需要将网卡监听的信道固定为11：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@kali:~<span class="comment"># airmon-ng start wlan0mon 11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PHY    Interface    Driver        Chipset</span><br><span class="line"></span><br><span class="line">phy0    wlan0mon    rt2800usb    Ralink Technology, Corp. RT2870/RT3070</span><br><span class="line"></span><br><span class="line">        (mac80211 monitor mode already enabled <span class="keyword">for</span> [<span class="type">phy0</span>]wlan0mon on [<span class="type">phy0</span>]<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>看到命令行中最后一行括号里的提示，表示已经设置为固定监听信道11。</p>
<p>此时打开wireshark，选中网卡wlan0mon即可捕获。</p>
<h1 id="WPA四次握手"><a href="#WPA四次握手" class="headerlink" title="WPA四次握手"></a>WPA四次握手</h1><p>在上一篇文章《Wi-Fi攻击方式简述》中，已经对WPA的握手过程进行过简单讲解，总结起来WPA的四次握手完成了：</p>
<p>1）Wi-Fi密码的验证</p>
<p>2）后续信道加密的密码的确认（注意这里不是“传输”）</p>
<p>而在其握手过程中，会生成一些过程产物，如加密握手数据的密钥、完整性校验数据等。密钥计算的总览视图如下：</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200629154441387.png" alt="image-20200629154441387"></p>
<p>四次握手的简单示意图：</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/686769-20161117152254170-216963418.png" alt="686769-20161117152254170-216963418"></p>
<p>接下来会逐步介绍每一步的计算过程。</p>
<h2 id="握手前的准备：计算PMK"><a href="#握手前的准备：计算PMK" class="headerlink" title="握手前的准备：计算PMK"></a>握手前的准备：计算PMK</h2><p><strong>PMK(Pairwise Master Key)</strong> 是整个WPA认证过程中非常核心的一个密钥，是由Wi-Fi的<code>SSID</code>和<code>Pre-Shared-Key</code>（即Wi-Fi密码）计算而来，其算法被称为Password-Based Key Derivation Function 2 (PBKDF2) ，是一种使用HMAC-SHA1，使用SSID作为盐值来进行哈希的一种算法。</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200629170801055.png" alt="image-20200629170801055"></p>
<p>在默认的Python环境中，需要安装<code>pbkdf2</code>库来支持这种算法，可以使用<code>pip install pbkdf2</code>命令来安装 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pbkdf2 <span class="keyword">import</span> PBKDF2</span><br><span class="line"></span><br><span class="line">psk = <span class="string">&quot;Induction&quot;</span></span><br><span class="line">ssid = <span class="string">&quot;Coherer&quot;</span></span><br><span class="line">pmk = PBKDF2(psk, ssid, <span class="number">4096</span>).read(<span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200629165810353.png" alt="image-20200629165810353"></p>
<p>此外，可以利用Linux系统中的<code>wpa_passphrase</code>工具来计算PMK，其命令为：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pentest@DESKTOP<span class="literal">-2AE07FJ</span>:~<span class="variable">$</span> wpa_passphrase Coherer Induction</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200629165935651.png" alt="image-20200629165935651"></p>
<p>这里可以看出来，计算出来的值是一致的。</p>
<h2 id="第一次握手：传递ANonce，STA计算PTK"><a href="#第一次握手：传递ANonce，STA计算PTK" class="headerlink" title="第一次握手：传递ANonce，STA计算PTK"></a>第一次握手：传递ANonce，STA计算PTK</h2><p>在WPA的第一次握手时，由AP向STA发送<code>ANonce</code>：</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200629170336475.png" alt="image-20200629170336475"></p>
<p>在这个数据包中，除了 <code>ANonce</code> 以外，在头部包含了双方的MAC地址。此时<strong>STA本地生成SNonce，满足了PTK计算的全部条件，因此进行PTK的计算</strong>。</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200629171145032.png" alt="image-20200629171145032"></p>
<p><strong>由于SNonce在第二次握手的数据包中，因此这部分的演示在下一节进行。</strong></p>
<h2 id="第二次握手：传递SNonce，AP计算PTK"><a href="#第二次握手：传递SNonce，AP计算PTK" class="headerlink" title="第二次握手：传递SNonce，AP计算PTK"></a>第二次握手：传递SNonce，AP计算PTK</h2><p>第二次握手时，STA向AP发送SNonce：</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200629171638896.png" alt="image-20200629171638896"></p>
<p>PTK（Pairwise Transient Key）的计算需要使用<strong>PRF512</strong>算法，其实现是参照《<a href="https://www.shellvoide.com/wifi/understanding-wpa-wpa2-hash-mic-cracking-process-python/">Understanding WPA/WPA2 Hash (MIC) Cracking Process In Python</a>》文章中给出的算法进行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">customPRF512</span>(<span class="params">key, A, B</span>):</span></span><br><span class="line">    blen = <span class="number">64</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    R = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= ((blen * <span class="number">8</span> + <span class="number">159</span>) / <span class="number">160</span>):</span><br><span class="line">        hmacsha1 = hmac.new(key, A + chr(<span class="number">0x00</span>) + B + chr(i), hashlib.sha1)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        R = R + hmacsha1.digest()</span><br><span class="line">    <span class="keyword">return</span> R[:blen]</span><br></pre></td></tr></table></figure>

<p>从前两次握手包中提取的<code>ANonce</code>、<code>SNonce</code> 以及双方的MAC地址，拼接起来作为计算PTK的部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mac_ap = binascii.unhexlify(<span class="string">&quot;000c4182b255&quot;</span>)</span><br><span class="line">mac_cl = binascii.unhexlify(<span class="string">&quot;000d9382363a&quot;</span>)</span><br><span class="line">anonce = binascii.unhexlify(<span class="string">&quot;3e8e967dacd960324cac5b6aa721235bf57b949771c867989f49d04ed47c6933&quot;</span>)</span><br><span class="line">snonce = binascii.unhexlify(<span class="string">&quot;cdf405ceb9d889ef3dec42609828fae546b7add7baecbb1a394eac5214b1d386&quot;</span>)</span><br><span class="line">key_data = min(mac_ap, mac_cl) + max(mac_ap, mac_cl) + min(anonce,snonce) + max(anonce,snonce)</span><br></pre></td></tr></table></figure>

<p><code>PRF512</code>需要3个参数，<code>PMK</code>，<code>PKE</code> 和上面计算出来的 <code>key_data</code>。其中<code>PKE</code>是一个固定字符串，<code>PMK</code>在前文中有过计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pke = <span class="string">&quot;Pairwise key expansion&quot;</span></span><br><span class="line">pmk = PBKDF2(<span class="string">&quot;Induction&quot;</span>, <span class="string">&quot;Coherer&quot;</span>, <span class="number">4096</span>).read(<span class="number">32</span>)</span><br><span class="line">ptk = customPRF512(pmk, pke, key_data)</span><br><span class="line"><span class="comment"># 此处ptk的值(Hex String)为：b1cd792716762903f723424cd7d1651182a644133bfa4e0b75d96d230835843315798d511beae0028313c8ab32f12c7ecb71c893482669daaf0e9223fe1c0aed</span></span><br></pre></td></tr></table></figure>

<p>到这里，AP和STA各自都计算出了PTK（正常情况下双方算出的PTK内容是一致的）。</p>
<h2 id="PTK的构成"><a href="#PTK的构成" class="headerlink" title="PTK的构成"></a>PTK的构成</h2><p>上一步骤中，计算出来的PTK是一个512bit的字符串（64字节），这是由于我们下载的Wireshark官方提供的样例包中的WPA采用的是TKIP加密，如果是CCMP加密，这里的算法会有所区别，因为计算出的PTK应当为384bit。</p>
<p>此处以TKIP加密为例，512bit的字符串可以分割为3个部分：KCK、KEK 和 TK。</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200629191743423.png" alt="image-20200629191743423"></p>
<p><strong>KCK (Key Confirmation Key)：</strong>用于计算WPA EAPOL密钥消息的MIC（完整性验证）</p>
<p><strong>KEK (Key Encryption Key)：</strong>用于加密发送到客户端的附加数据（在“密钥数据”字段中）</p>
<p><strong>TK (Temporal Key)：</strong>用于后续通信数据加密</p>
<p>TKIP加密模式下，PTK共512bit，其中按顺序为：KCK（128bit），KEK（128bit），TK（256bit）</p>
<p>CCMP加密模式下，PTK共384bit，其中按顺序为：KCK（128bit），KEK（128bit），TK（128bit）</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200630095341818.png" alt="image-20200630095341818"></p>
<p>如上节中计算的PTK，按照长度划分，应为：</p>
<p>KCK = b1cd792716762903f723424cd7d16511</p>
<p>KEK = 82a644133bfa4e0b75d96d2308358433</p>
<p>TK = 15798d511beae0028313c8ab32f12c7ecb71c893482669daaf0e9223fe1c0aed</p>
<h2 id="验证MIC"><a href="#验证MIC" class="headerlink" title="验证MIC"></a>验证MIC</h2><p>比较第一次和第二次握手，在数据包中会发现在<code>WPA Key MIC</code>字段中由原来的全0变成了一串字符：</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200629202936492.png" alt="image-20200629202936492"></p>
<p><strong>MIC (Message Integrity Code)：</strong>消息完整性代码 是校验数据是否被篡改，以及PSK是否正确（因为MIC是由PTK参与计算，PTK由是由PSK生成）。</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200630100306995.png" alt="image-20200630100306995"></p>
<p>MIC的计算是以KCK为密钥（Key），整个802.1X报文为消息体（Message）进行HMAC运算得出的结果，共128bit。</p>
<p>顺便一提，WPA的密码离线破解也是利用PSK生成PMK，并根据握手包计算KCK，再生成MIC并对比原数据包中的MIC来确定密码是否正确。</p>
<p>在我们手工验证的时候，需要先将整个报文（这里以第二次握手为例）提取出来，并找到<code>WPA Key MIC</code>字段，将这部分内容替换成0，再计算。</p>
<p><img src="/2020/06/29/WPA%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20200630101214680.png" alt="image-20200630101214680"></p>
<p>这部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = binascii.unhexlify(<span class="string">&quot;0203007502010a00100000000000000000cdf405ceb9d889ef3dec42609828fae546b7add7baecbb1a394eac5214b1d386000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001630140100000fac020100000fac040100000fac020000&quot;</span>)</span><br><span class="line">mic = hmac.new(ptk[<span class="number">0</span>:<span class="number">16</span>], payload, hashlib.sha1).hexdigest()[:<span class="number">32</span>]</span><br></pre></td></tr></table></figure>

<p>至此，大部分的计算和校验任务已经结束。</p>
<h2 id="第三次握手：传递加密的GTK，STA安装TK"><a href="#第三次握手：传递加密的GTK，STA安装TK" class="headerlink" title="第三次握手：传递加密的GTK，STA安装TK"></a>第三次握手：传递加密的GTK，STA安装TK</h2><p>第三次握手，由AP向STA发送数据，其中MIC部分与上面的计算方式一致。STA接收到数据后，验证MIC通过则说明AP是有效的，双方PMK是一致的。</p>
<p>同时，在这个数据包中，包含了加密后的GTK。<strong>GTK (Group Temporal Key)</strong> 用于加密广播和多播数据。GTK加密的密钥为KEK，其解密和使用不在此详述。</p>
<p>当STA接收到第三次握手包并验证MIC通过后，会将计算出来的TK（PTK的最后一段）安装到系统中，作为后续的通信加密密钥。</p>
<h2 id="第四次握手：AP安装TK"><a href="#第四次握手：AP安装TK" class="headerlink" title="第四次握手：AP安装TK"></a>第四次握手：AP安装TK</h2><p>最后一次握手仅为STA向AP发送的确认信息，表示密钥已经安装完毕，此时AP端也会进行密钥安装，至此，双方的密钥安装全部结束，后续通信中按照前面步骤中的密钥进行通信。</p>
<h1 id="密钥重装攻击-KRACK-Attack"><a href="#密钥重装攻击-KRACK-Attack" class="headerlink" title="密钥重装攻击 KRACK Attack"></a>密钥重装攻击 KRACK Attack</h1><p>上文中简单梳理了一下WPA四次握手的过程，其中省略了一些部分。由于主要是想帮助对KRACK漏洞的理解，因此重点放在第三次握手的密钥安装部分，安装的密钥来源上。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>关于这一漏洞，感兴趣的可以参考《<a href="https://www.freebuf.com/articles/wireless/150953.html">WPA2 密钥重装攻击 KRACK Attacks 分析报告</a>》，个人感觉这篇文章解释的比较详细，总结起来这个漏洞就是：</p>
<blockquote>
    其中，wpa_supplicant 2.4及2.5版本实现了协议注释内容“一旦安装后，就可从内存中清除加密密钥”，将导致客户端会安装值全为零的秘钥。因此使用了这些wpa_supplicant版本的Linux及Android设备将遭受严重威胁。
</blockquote>

<p>这个漏洞是利用wpa_supplicant在第三次握手时对TK的处理来达到攻击的目的的。由于TK是根据第一次和第二次握手包中的数据生成，因此STA会将该密钥保存在本地的内存中。当收到第三次握手的数据包时，STA会将该密钥安装，并从内存中清除（“一旦安装后，就可从内存中清除加密密钥”），因此再次收到该握手包时，程序会再次加载这部分已被清零的内存，导致重新安装的密钥为全0。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>由于目前未找到直接的利用EXP/POC，在Github上有一个检测工具：<a href="https://github.com/vanhoefm/krackattacks-scripts%EF%BC%8C%E5%85%B6%E5%AE%98%E7%BD%91">https://github.com/vanhoefm/krackattacks-scripts，其官网</a> <a href="https://www.krackattacks.com/">https://www.krackattacks.com</a> 上有对这个漏洞的演示。</p>
<p>从原理和演示来看，KRACK漏洞需要搭建Rogue AP做中间人，转发握手数据帧。当发送第三次握手包时，进行重放。</p>
<p>由于多次接收到第三次握手包，STA会尝试安装全0的密钥，并使用密钥加密后续通信包。Rogue AP的通信密钥预先就被置为0，这样就可以正常的和STA通信。</p>
<p>目前没有时间来实践这个漏洞，仅从原理上对漏洞的利用方式进行分析，该漏洞更像是传统的Evil Twin的攻击方法，但Evil Twin需要知道目标AP的密码，才能让用户的设备顺利连入；而借助KRACK Attack，攻击者无需知道目标AP的密码即可实现中间人攻击，监听受害者流量。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>WPA的四次握手中，前两次是在互相交换计算PTK的信息（ANonce、SNonce），AP验证STA身份（利用MIC）并各自计算出PTK；第三次握手STA验证了AP的身份，传输加密GTK，并将计算出的TK安装；第四次握手确认密钥安装完成。</p>
<p>附：完整的计算MIC的 Python 代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pbkdf2 <span class="keyword">import</span> PBKDF2</span><br><span class="line"><span class="keyword">import</span> hmac, binascii, hmac, hashlib, sha</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">customPRF512</span>(<span class="params">key, A, B</span>):</span></span><br><span class="line">    blen = <span class="number">64</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    R = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= ((blen * <span class="number">8</span> + <span class="number">159</span>) / <span class="number">160</span>):</span><br><span class="line">        hmacsha1 = hmac.new(key, A + chr(<span class="number">0x00</span>) + B + chr(i), sha)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        R = R + hmacsha1.digest()</span><br><span class="line">    <span class="keyword">return</span> R[:blen]</span><br><span class="line"></span><br><span class="line">psk = <span class="string">&quot;Induction&quot;</span></span><br><span class="line">ssid = <span class="string">&quot;Coherer&quot;</span></span><br><span class="line">pmk = PBKDF2(psk, ssid, <span class="number">4096</span>).read(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">mac_ap = binascii.unhexlify(<span class="string">&quot;000c4182b255&quot;</span>)</span><br><span class="line">mac_cl = binascii.unhexlify(<span class="string">&quot;000d9382363a&quot;</span>)</span><br><span class="line">anonce = binascii.unhexlify(<span class="string">&quot;3e8e967dacd960324cac5b6aa721235bf57b949771c867989f49d04ed47c6933&quot;</span>)</span><br><span class="line">snonce = binascii.unhexlify(<span class="string">&quot;cdf405ceb9d889ef3dec42609828fae546b7add7baecbb1a394eac5214b1d386&quot;</span>)</span><br><span class="line"></span><br><span class="line">key_data = min(mac_ap, mac_cl) + max(mac_ap, mac_cl) + min(anonce,snonce) + max(anonce,snonce)</span><br><span class="line">pke = <span class="string">&quot;Pairwise key expansion&quot;</span></span><br><span class="line">ptk = customPRF512(pmk, pke, key_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;PTK Original:                &quot;</span>,ptk.encode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;EAPOL-Key Confirm Key:       &quot;</span>,ptk[:<span class="number">16</span>].encode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;EAPOL-Key Encrypt Key:       &quot;</span>,ptk[<span class="number">16</span>:<span class="number">32</span>].encode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;(TKIP|CCMP) Temporal Key:    &quot;</span>,ptk[<span class="number">32</span>:].encode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = binascii.unhexlify(<span class="string">&quot;0203007502010a00100000000000000000cdf405ceb9d889ef3dec42609828fae546b7add7baecbb1a394eac5214b1d386000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001630140100000fac020100000fac040100000fac020000&quot;</span>)</span><br><span class="line"></span><br><span class="line">mic = hmac.new(ptk[<span class="number">0</span>:<span class="number">16</span>], payload, hashlib.sha1).hexdigest()[:<span class="number">32</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;MIC (Message Integrity Code):&quot;</span>,mic</span><br></pre></td></tr></table></figure>



<p><strong>参考链接</strong></p>
<p>[1] <a href="WPA/RSN%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8CPTK">WPA/RSN四次握手和PTK</a></p>
<p>[2] <a href="https://dalewifisec.wordpress.com/2013/06/03/keys-keys-and-even-more-keys/">KEYS, KEYS, AND EVEN MORE KEYS!</a></p>
<p>[3] <a href="WPA/WPA2-PSK%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B">WPA/WPA2-PSK认证过程</a></p>
<p>[4] <a href="https://www.jianshu.com/p/392362718d68">四次握手</a></p>
<p>[5] <a href="https://www.cnblogs.com/efzju/p/3199330.html">安全协议系列（二）—-CCM与CCMP</a></p>
<p>[6] <a href="https://www.krackattacks.com/">https://www.krackattacks.com/</a></p>
<p>[7] <a href="https://github.com/vanhoefm/krackattacks-scripts">https://github.com/vanhoefm/krackattacks-scripts</a></p>
<p>[8] <a href="https://www.freebuf.com/articles/wireless/153255.html">国内研究人员首次Wifi重大漏洞利用实现 | Krack攻击测试套件打包</a></p>
<p>[9] <a href="https://www.freebuf.com/articles/wireless/150953.html">WPA2 密钥重装攻击 KRACK Attacks 分析报告</a></p>
<p>[10] <a href="https://www.shellvoide.com/wifi/understanding-wpa-wpa2-hash-mic-cracking-process-python/">Understanding WPA/WPA2 Hash (MIC) Cracking Process In Python</a></p>
<p>[11] <a href="https://wiki.wireshark.org/HowToDecrypt802.11">HowToDecrypt802.11</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Wi-Fi</tag>
        <tag>WPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi攻击方式简述</title>
    <url>/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<p>Wi-Fi安全是一个老生常谈的问题了，各种攻击方式也被总结的很多了，但大部分都在说原理和流程，很少有深入到细节分析的。</p>
<a id="more"></a>

<p><strong>Wi-Fi</strong>（发音： [/ˈwaɪfaɪ/]），又称“无线热点”或“无线网络”，是Wi-Fi联盟的商标，一个基于IEEE 802.11标准的无线局域网技术[1]。IEEE 802.11是IEEE 802标准委员会（IEEE 802 LAN/MAN Standards Committee）下属的无线局域网工作组，也指代由该组织制定的无线局域网标准[2]。目前我们常用的Wi-Fi标准为802.11 a/b/g/n/ac这5中，其中802.11 b/g/n 在 2.4GHz频段使用较多，近几年来兴起的5GHz则是以 802.11 n/ac为主。</p>
<h2 id="802-11协议"><a href="#802-11协议" class="headerlink" title="802.11协议"></a>802.11协议</h2><p>802.11协议的初始版本发布于1997年，随后对无线传输的速率、安全性等不断进行更新，发布了众多的协议和版本。其中我们生活中普遍接触的有802.11 a/b/g/n/ac这几种协议。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>频率</th>
<th>调制方式</th>
<th>最大传输速率</th>
<th>发布时间</th>
</tr>
</thead>
<tbody><tr>
<td>802.11</td>
<td>2.4Ghz</td>
<td>FHSS ， DSSS</td>
<td>2Mbps</td>
<td>1997</td>
</tr>
<tr>
<td>802.11a</td>
<td>5GHz</td>
<td>OFDM</td>
<td>54Mbps</td>
<td>1999</td>
</tr>
<tr>
<td>802.11b</td>
<td>2.4GHz</td>
<td>DSSS</td>
<td>11Mbps</td>
<td>1999</td>
</tr>
<tr>
<td>802.11g</td>
<td>2.4GHz</td>
<td>DSSS，OFDM</td>
<td>54Mbps</td>
<td>2003</td>
</tr>
<tr>
<td>802.11n</td>
<td>2.4GHz或5GHz</td>
<td>MIMO-OFDM</td>
<td>150Mbps(单条流，40M频宽)</td>
<td>2009</td>
</tr>
<tr>
<td>802.11ac</td>
<td>2.4GHz或5GHz</td>
<td>MIMO-OFDM</td>
<td>866.7Mbps(单条流，160M频宽)</td>
<td>2013</td>
</tr>
</tbody></table>
<p>在主流家用路由器的无线设置中都支持修改协议。</p>
<h2 id="802-11无线帧"><a href="#802-11无线帧" class="headerlink" title="802.11无线帧"></a>802.11无线帧</h2><p>对于不同的802.11协议，其区别主要集中在物理层对数据的编码、调制、MIMO支持上，而在设备接入、认证方面几乎是相同的。</p>
<p>下图为802.11无线帧的格式，该帧位于数据链路层。</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/xxMACFrameFormat.png" alt="img"></p>
<p>其中，<code>MAC Header</code>部分为帧的控制字段，表示帧类型、源目的地址等；<code>Frame Body</code>部分则是承载的数据，其内容会根据帧类型而有所不同；<code>FCS</code>是“Frame Check Sequence（帧校验序列）”的缩写，保证帧的完整性。</p>
<p><code>MAC Header -&gt; Frame Control -&gt; Type</code>定义了当前帧的分类。802.11无线帧中有三种帧类型：数据帧、控制帧和管理帧。</p>
<p><strong>数据帧</strong>主要是传输数据、进行ACK响应、QoS等；<strong>控制帧</strong>主要控制传输速率、协商信道以及保证信道畅通（实现CSMA/CA载波侦听/冲突避免）；而<strong>管理帧</strong>则是负责站点的探测、关联认证、解除关联等动作，这部分也是大部分Wi-Fi安全关注的部分。</p>
<p>下面就详细说明一下802.11管理帧。</p>
<p>管理帧的类型如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Association Request(关联请求)</span><br><span class="line">Association Response (关联响应)</span><br><span class="line">Reassociation Request(重关联请求)</span><br><span class="line">Reassociation Response(重关联响应)</span><br><span class="line">Probe Request(探测请求)</span><br><span class="line">Probe Response(探测响应)</span><br><span class="line">Beacon(信标帧)</span><br><span class="line">ATIM(通知传输指示信息)</span><br><span class="line">Disassociation(解除关联)</span><br><span class="line">Authentication(身份验证)</span><br><span class="line">Deauthentication(解除身份验证)</span><br></pre></td></tr></table></figure>

<p>站点接入基站的过程主要分为四步：扫描（获取附近基站信息）、连接（身份认证）、传输（与基站交换信息）、断开。</p>
<p>先引入一个全局视图：</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200623100438495.png" alt="image-20200623100438495"></p>
<h2 id="扫描阶段"><a href="#扫描阶段" class="headerlink" title="扫描阶段"></a>扫描阶段</h2><p>扫描对于用户操作来说直观感受就是打开Wi-Fi列表，看到设备发现附近热点的名称。扫描分为两种方式，<strong>主动扫描和被动扫描</strong>。</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200619150224845.png" alt="image-20200619150224845"></p>
<h3 id="主动扫描"><a href="#主动扫描" class="headerlink" title="主动扫描"></a>主动扫描</h3><p>主动扫描指的是站点在对应信道上主动广播一个探测请求（Probe Request），并等待基站的响应。</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200610101310303.png" alt="image-20200610101310303"></p>
<p>在发送Probe Request帧时，其中<code>SSID</code>字段若<strong>有指定的字符</strong>，则称为 “Directed probe（直接探测）”，此时若该信道上存在对应SSID名称的基站则会发送探测响应；而<code>SSID</code>字段为<code>NULL</code>时，该帧称为 “Broadcast probe（广播探测）”，对应信道上所有接收到这个帧的基站均会发送探测响应。</p>
<p>在主动扫描模式下，由于站点会广播Probe Request帧，如果攻击者违背协议规定，对所有收到的Probe Request进行响应，则会造成<strong>Wi-Fi钓鱼</strong>的攻击。具体例子可以参考《<a href="https://www.freebuf.com/articles/77055.html">WiFi Pineapple的Karma攻击与原理探究</a>》、《<a href="https://www.freebuf.com/articles/wireless/145259.html">聊聊WiFi Hacks：为何你的Karma攻击不好使了</a>》。</p>
<h3 id="被动扫描"><a href="#被动扫描" class="headerlink" title="被动扫描"></a>被动扫描</h3><p>被动扫描是通过被动接受基站定期发送的Beacon包来发现周围热点的方式。一般来说，使用被动扫描可以有效规避Wi-Fi钓鱼的攻击。然而站点（无线客户端）在收到的Beacon包中如果发现自己连接过的SSID，则会尝试连接。利用这种特性，如果攻击者尝试大量枚举SSID，尤其是公共Wi-Fi的SSID（如星巴克、麦当劳、肯德基等）则依然可以实现Wi-Fi钓鱼攻击（参见《<a href="https://www.freebuf.com/articles/wireless/44378.html">主动触发被动模式从而挟持无线客户端 – Passive Karma Attack</a>》）。</p>
<p>此外，利用扫描阶段的机制，可以进行<strong>伪AP（Rouge AP）</strong>攻击。伪AP主要通过设置一个与真实AP名称、加密方式、密码都相同的热点，并利用无线客户端在扫描到多个名称和加密方式相同的热点时会优先选择信号最好的连接这一特性，引导无线客户端连接到攻击者设置的伪AP上，进而进行中间人、嗅探等一系列攻击。其实现原理可参见《<a href="https://www.docin.com/p-1668171406.html">基于伪AP的无线局域网中间人攻击方法及隐患分析</a>》，搭建方法可参见《<a href="https://www.freebuf.com/news/141977.html">无线安全课堂：手把手教会你搭建伪AP接入点</a>》。</p>
<h3 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h3><p><strong>Kismet</strong></p>
<p>Kismet是802.11 数据链路层的扫描器和嗅探器。它会将无线网卡设置为Monitor Mode，监听并记录附近所有的无线流量，分析热点和设备的配对关系等。详细介绍和用法可以参考：<a href="https://tools.kali.org/wireless-attacks/kismet">Kismet Package Description</a></p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/kismet.png" alt="kismet"></p>
<h2 id="接入阶段"><a href="#接入阶段" class="headerlink" title="接入阶段"></a>接入阶段</h2><p>当扫描完成，用户选择某一个AP进行接入，或无线客户端自动连接某AP时，进入接入阶段。</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200619150312552.png" alt="image-20200619150312552"></p>
<p>接入阶段分为两个部分，参数协商和密码验证。Association Request 和 Association Response帧负责协商接入AP的STA是否满足要求（如支持的频段、速率、信道等）；Authentication帧负责协商认证算法（开放式、PSK、SAE等）和一些辅助数据（如Challenge Text等, WEP加密会在这个阶段传输认证数据）。</p>
<p>802.11支持的加密方式很多，如下图为OpenWRT系统中提供的加密方式：</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200619151741540.png" alt="image-20200619151741540"></p>
<h3 id="WEP认证"><a href="#WEP认证" class="headerlink" title="WEP认证"></a>WEP认证</h3><p>WEP认证有两种方式，“WEP 开放式系统” 和 “WEP 共享密钥”两种方式。</p>
<p>“WEP 开放式系统” 指的是，任意客户端（STA）都可以连入热点（AP），但是在信道上传输的数据依然使用WEP提供的加密方式加密；而 “WEP 共享密钥” 则需要在接入之前先验证密钥，当验证通过之后才允许STA接入。</p>
<p><strong>“WEP 共享密钥”</strong> 的认证过程如下图所示：</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200619164809124.png"></p>
<p>其简单的流程为，AP端在认证过程中向STA发送一个<code>Challenge Text</code>，由STA加密后将密文传送给AP，AP端校验收到的密文与自己计算的密文如果相等则允许站点接入，否则将拒绝。使用Wireshark抓包的流程如下：</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200619164643763.png"></p>
<p>认证通过后，后续的数据包的内容都以WEP的密钥流进行加密，STA需要以相同的密钥流解密，才能正常的收发数据。</p>
<p>**“WEP 开放式系统” ** 则跳过了这一认证阶段，允许任何STA加入网络，但后续通信中的数据包是加密的。因此即使STA连入AP，但没有正确的密码也无法正常通信。可以通过简单的实验来验证：</p>
<ol>
<li>将路由器的加密配置为 “WEP 开放系统”， 并配置密码；</li>
<li>用手机或电脑（STA）尝试连入该AP，密码输入任意字符（但别输正确的密码）；</li>
<li>此时发现STA显示已连接，但是会卡在“获取IP地址”的部分（如果路由器开启了DHCP）；</li>
<li>即使手动配置IP后，依然无法进行通信。</li>
</ol>
<p>以上的实验中，无法获取到IP地址或配置IP后无法通信，是因为密码错误，STA无法解密数据包，因此无法通信。</p>
<h3 id="WEP密码破解"><a href="#WEP密码破解" class="headerlink" title="WEP密码破解"></a>WEP密码破解</h3><p>WEP密码破解的应用实际上工具很多，如Besside-ng，AirCrack-ng等，以及很多集成该功能的无线安全审计套件，其教程也很容易搜索到。这里简单介绍一下其破解原理。</p>
<p>WEP是一个已经被完全破解的加密算法，其原理涉及到密码学和数学的很多知识，这里不展开详细叙述，感兴趣的可以去看看《<a href="https://zhuanlan.zhihu.com/p/57677761">密码分析学——深度分析WEP密钥恢复攻击（PTW攻击）</a>》，其中对WEP破解的每一步原理都有详细的分析，本人觉得是写得非常好的一篇文章。</p>
<p>RC4 流密码算法是将输入种子密钥进行某种置换和组合运算来生成WEP密钥流的，发送的数据与该密钥流异或，则得到最终的密文。而加密数据（负载）的第一个字节是802.2逻辑链路层的头部数据，而每个数据帧的该字节都是一样的，因此可以得到密文的第一个字节、对应的明文字节。</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200622102900122.png" alt="image-20200622102900122"></p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200622103037907.png" alt="image-20200622103037907"></p>
<blockquote>
<p>注：使用Wireshark解密可参考官方文档《<a href="https://wiki.wireshark.org/HowToDecrypt802.11">How to Decrypt 802.11</a>》</p>
</blockquote>
<p>同时，IV信息是包含在头部信息中一起传输的，因此已知 初始向量IV、第一字节密钥流、第一字节明文，针对RC4算法是可以计算并确定WEP密钥。</p>
<h3 id="WPA四次握手"><a href="#WPA四次握手" class="headerlink" title="WPA四次握手"></a>WPA四次握手</h3><p>WPA的认证过程与WEP略有区别。大致的连接、认证过程如下图：</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200622103724702.png" alt="image-20200622103724702"></p>
<p>在Authentication阶段，WPA并不进行实际认证，而是传输<code>Open System</code>来直接允许STA连入：</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200622103548051.png" alt="image-20200622103548051"></p>
<p>而实际的密钥认证在“四次握手”阶段。</p>
<p>“WPA 四次握手” 是验证密钥，并且生成对数据包的加密密钥的过程。流程如下：</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/686769-20161117152254170-216963418.png" alt="img"></p>
<p>连接过程中，用户输入的 ”WPA密码“ 在认证过程中称为<code>PSK(Pre-Shared Key)</code>，即 ”预共享密钥“。利用<code>PSK</code>以及无线网络的<code>ssid</code>，使用 ”PBKDF2“ 算法可以计算出<code>PMK</code>。利用<code>PMK</code>，以及认证过程中传输的<code>ANonce</code>、<code>SNonce</code>、<code>STA的MAC地址</code>、<code>AP的MAC地址</code>，使用hmac sha1算法可以计算出<code>PTK</code>。最后使用<code>PTK</code>的前16个字节以及整个<code>802.1X Authentication</code>数据包，计算出<code>MIC</code>。</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200622112834875.png" alt="image-20200622112834875"></p>
<h3 id="WPA-PSK密码破解"><a href="#WPA-PSK密码破解" class="headerlink" title="WPA-PSK密码破解"></a>WPA-PSK密码破解</h3><p>从上面的流程中可以看出，密钥的认证使用摘要算法，因此破解方式只能是暴力破解。但是计算步骤中，除了Wi-Fi密码（PSK）外，所有参数都可以从交互的数据包中获取，因此可以捕获STA的接入包进行离线破解。最终通过计算出的MIC与捕获包中的MIC比对，得出最终结果。</p>
<p>在整个暴力破解过程中，PMK的计算是最耗时的，同时因为PMK与<code>SSID</code>直接相关，因此生成字典较难复用；同时需要有足够大的密码字典才能提高命中率，而巨大的密码字典的生成与保存也是一个问题。</p>
<h3 id="WPS认证与破解"><a href="#WPS认证与破解" class="headerlink" title="WPS认证与破解"></a>WPS认证与破解</h3><p>WPS 是 Wi-Fi Protected Setup（Wi-Fi保护设置）的缩写，为了简化STA与AP的连接过程。在使用WPS接入网络的过程中，用户仅需要输入8位数字组成的PIN码，即可接入网络。在这一过程中，STA与AP之间通过<code>EAP Request</code>和<code>EAP Response</code>帧来验证用户输入的PIN码，并传输后续的信息（如SSID、密码等）。</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200623093408305.png" alt="image-20200623093408305"></p>
<p>图片来自：<a href="https://netsecurity.51cto.com/art/201504/471508_all.htm">https://netsecurity.51cto.com/art/201504/471508_all.htm</a></p>
<p>由于PIN码为8位纯数字，因此理论上有10 ^ 8 中不同的组合；而一般情况下，每次验证PIN码需要3~10秒左右的时间（与信号强度、干扰等有关），因此在理论上来看，即使以 3sec/PIN 的速度破解， 10 ^ 8 个PIN码遍历完需要 （10 ^ 8 * 3) / 3600 / 24 = 3472.2天，因此在理论上来说这种方式应对暴力破解是完全没有问题的。</p>
<p>但是，在协议设计的时候，第8位 PIN 为校验位，因此实际需要暴力破解的位数变成7位。此外，在验证 PIN 码失败后，AP会返回<code>EAP-NACK</code>的响应包，通过响应包的内容，可以分别判断前4位和后3位是否正确（由于手边没有支持WPS的路由器，因此此部分无法抓包验证）。</p>
<p>基于这样的特性，WPS的暴力破解变成了分别猜解前4位和后3位，即 (10 ^ 4 + 10 ^ 3) 种可能性，依然按照 3sec/PIN 的速度推算，完整跑完全部PIN需要约 9.16小时，而根据在网上搜索破解WPS的结果来看，即使信号不好（如破解隔壁邻居的AP），时间也不超过12小时即可跑出结果。</p>
<h3 id="相关工具-1"><a href="#相关工具-1" class="headerlink" title="相关工具"></a>相关工具</h3><p><strong><a href="https://tools.kali.org/wireless-attacks/cowpatty">coWPAtty</a></strong> 是一个WPA/WPA2离线破解工具，可以生成PMK字典并且计算MIC来进行密码破解。其生成字典的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@kali:~<span class="comment"># genpmk -f /usr/share/wordlists/nmap.lst -d cowpatty_dict -s securenet</span></span><br><span class="line">genpmk 1.3 - WPA-PSK precomputation attack. \&amp;lt;jwright@hasborg.com\&amp;gt;</span><br><span class="line">File cowpatty_dict does not exist, creating.</span><br><span class="line">key no. 1000: pinkgirl</span><br><span class="line">1641 passphrases tested <span class="keyword">in</span> 3.60 seconds: 456.00 passphrases/second</span><br></pre></td></tr></table></figure>

<p><strong><a href="https://tools.kali.org/wireless-attacks/wifite">Wifite</a></strong> 是一个综合性的无线安全审计工具，集成了WPA/WPA2、WEP等破解工具。用法简单便捷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@kali:~<span class="comment"># wifite -h</span></span><br><span class="line"></span><br><span class="line">  .;<span class="string">&#x27;                     `;,</span></span><br><span class="line"><span class="string"> .;&#x27;</span>  ,;<span class="string">&#x27;             `;,  `;,   WiFite v2 (r85)</span></span><br><span class="line"><span class="string">.;&#x27;</span>  ,;<span class="string">&#x27;  ,;&#x27;</span>     `;,  `;,  `;,</span><br><span class="line">::   ::   :   ( )   :   ::   ::  automated wireless auditor</span><br><span class="line"><span class="string">&#x27;:.  &#x27;</span>:.  <span class="string">&#x27;:. /_\ ,:&#x27;</span>  ,:<span class="string">&#x27;  ,:&#x27;</span></span><br><span class="line"> <span class="string">&#x27;:.  &#x27;</span>:.    /___\    ,:<span class="string">&#x27;  ,:&#x27;</span>   designed <span class="keyword">for</span> Linux</span><br><span class="line">  <span class="string">&#x27;:.       /_____\      ,:&#x27;</span></span><br><span class="line">           /       \</span><br><span class="line"></span><br><span class="line">   COMMANDS</span><br><span class="line">    -check &lt;file&gt;   check capfile &lt;file&gt; <span class="keyword">for</span> handshakes.</span><br><span class="line">    -cracked        display previously-cracked access points</span><br><span class="line"></span><br><span class="line">   GLOBAL</span><br><span class="line">    -all            attack all targets.              [off]</span><br><span class="line">    -i &lt;iface&gt;      wireless interface <span class="keyword">for</span> capturing [auto]</span><br><span class="line">    -mac            anonymize mac address            [off]</span><br><span class="line">    -c &lt;channel&gt;    channel to scan <span class="keyword">for</span> targets      [auto]</span><br><span class="line">    -e &lt;essid&gt;      target a specific access point by ssid (name)  [ask]</span><br><span class="line">    -b &lt;bssid&gt;      target a specific access point by bssid (mac)  [auto]</span><br><span class="line">    -showb          display target BSSIDs after scan               [off]</span><br><span class="line">    -pow &lt;db&gt;       attacks any targets with signal strenghth &gt; db [0]</span><br><span class="line">    -quiet          <span class="keyword">do</span> not <span class="built_in">print</span> list of APs during scan           [off]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   WPA</span><br><span class="line">    -wpa            only target WPA networks (works with -wps -wep)   [off]</span><br><span class="line">    -wpat &lt;sec&gt;     time to <span class="built_in">wait</span> <span class="keyword">for</span> WPA attack to complete (seconds) [500]</span><br><span class="line">    -wpadt &lt;sec&gt;    time to <span class="built_in">wait</span> between sending deauth packets (sec) [10]</span><br><span class="line">    -strip          strip handshake using tshark or pyrit             [off]</span><br><span class="line">    -crack &lt;dic&gt;    crack WPA handshakes using &lt;dic&gt; wordlist file    [off]</span><br><span class="line">    -dict &lt;file&gt;    specify dictionary to use when cracking WPA [phpbb.txt]</span><br><span class="line">    -aircrack       verify handshake using aircrack [on]</span><br><span class="line">    -pyrit          verify handshake using pyrit    [off]</span><br><span class="line">    -tshark         verify handshake using tshark   [on]</span><br><span class="line">    -cowpatty       verify handshake using cowpatty [off]</span><br><span class="line"></span><br><span class="line">   WEP</span><br><span class="line">    -wep            only target WEP networks [off]</span><br><span class="line">    -pps &lt;num&gt;      <span class="built_in">set</span> the number of packets per second to inject [600]</span><br><span class="line">    -wept &lt;sec&gt;     sec to <span class="built_in">wait</span> <span class="keyword">for</span> each attack, 0 implies endless [600]</span><br><span class="line">    -chopchop       use chopchop attack      [on]</span><br><span class="line">    -arpreplay      use arpreplay attack     [on]</span><br><span class="line">    -fragment       use fragmentation attack [on]</span><br><span class="line">    -caffelatte     use caffe-latte attack   [on]</span><br><span class="line">    -p0841          use -p0841 attack        [on]</span><br><span class="line">    -hirte          use hirte (cfrag) attack [on]</span><br><span class="line">    -nofakeauth     stop attack <span class="keyword">if</span> fake authentication fails    [off]</span><br><span class="line">    -wepca &lt;n&gt;      start cracking when number of ivs surpass n [10000]</span><br><span class="line">    -wepsave        save a copy of .<span class="built_in">cap</span> files to this directory [off]</span><br><span class="line"></span><br><span class="line">   WPS</span><br><span class="line">    -wps        only target WPS networks         [off]</span><br><span class="line">    -wpst &lt;sec&gt;     max <span class="built_in">wait</span> <span class="keyword">for</span> new retry before giving up (0: never)  [660]</span><br><span class="line">    -wpsratio &lt;per&gt; min ratio of successful PIN attempts/total tries    [0]</span><br><span class="line">    -wpsretry &lt;num&gt; max number of retries <span class="keyword">for</span> same PIN before giving up [0]</span><br><span class="line"></span><br><span class="line">   EXAMPLE</span><br><span class="line">    ./wifite.py -wps -wep -c 6 -pps 600</span><br><span class="line"></span><br><span class="line"> [+] quitting</span><br></pre></td></tr></table></figure>

<p>**<a href="https://tools.kali.org/wireless-attacks/pyrit">Pyrit</a>**支持离线破解，可指定含有WPA四次握手的捕获数据包进行破解。该工具还可以生成PMK字典文件，加速破解进度。具体用法可参见工具<a href="https://github.com/JPaulMora/Pyrit/wiki/Usage">官方Github</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@kali:~<span class="comment"># pyrit -i /usr/share/wordlists/metasploit/password.lst import_passwords</span></span><br><span class="line">Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora</span><br><span class="line">https://github.com/JPaulMora/Pyrit</span><br><span class="line">This code is distributed under the GNU General Public License v3+</span><br><span class="line"></span><br><span class="line">Connecting to storage at <span class="string">&#x27;file://&#x27;</span>...  connected.</span><br><span class="line">88396 lines <span class="built_in">read</span>. Flushing buffers....</span><br><span class="line">All <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p>**<a href="https://tools.kali.org/wireless-attacks/reaver">Reaver</a>**是一款破解WPS PIN码并获取目标AP接入密码的工具。其官方宣称：理论破解时间在2~10小时，实际破解时间为理论时间的一半。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@kali:~<span class="comment"># reaver -i wlan0mon -b E0:3F:49:6A:57:78 -v</span></span><br><span class="line"></span><br><span class="line">Reaver v1.6.5 WiFi Protected Setup Attack Tool</span><br><span class="line">Copyright (c) 2011, Tactical Network Solutions, Craig Heffner &lt;cheffner@tacnetsol.com&gt;</span><br><span class="line"></span><br><span class="line">[+] Waiting <span class="keyword">for</span> beacon from E0:3F:49:6A:57:78</span><br><span class="line">[+] Associated with E0:3F:49:6A:57:78 (ESSID: ASUS)</span><br><span class="line">[+] Trying pin 12345670</span><br></pre></td></tr></table></figure>



<h2 id="断开阶段"><a href="#断开阶段" class="headerlink" title="断开阶段"></a>断开阶段</h2><p>断开阶段有两种数据帧：<code>Deauthenticaion（解除认证）</code>和<code>Deassociation（解除关联）</code>。</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200622143155410.png" alt="image-20200622143155410"></p>
<p>一般情况下，我们在日常使用的时候很少会经历这个阶段，或者说对用户是无感的。当用户切换Wi-Fi连接时，在Wireshark中捕获到相关的数据帧如下：</p>
<p><img src="/2020/06/05/Wi-Fi%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%AE%80%E8%BF%B0/image-20200622142620358.png" alt="image-20200622142620358"></p>
<p>一般的，在802.11关联过程（Association process, 即本文提及的接入阶段）中，会经历4种状态：</p>
<ol>
<li>未认证、未关联</li>
<li>已认证但未关联</li>
<li>已认证、已关联</li>
<li>已认证、已关联且已通过802.1x认证</li>
</ol>
<p>起初STA处于<strong>状态1</strong>，AP端会与STA协商采用怎样的认证（该部分可以参见 “WEP认证” 章节），如“开放系统”等。当协商完成并进行认证后，进入<strong>状态2</strong>。此时双方关联(Association Request / Response)，进入<strong>状态3</strong>。</p>
<p>此时，如果加密方式需要802.1x认证（如WPA-PSK），则开始这一步骤，完成后进入<strong>状态4</strong>。在状态4中，如果双方收到<code>Deassociation</code>帧，则<strong>退回到状态2</strong>；如果收到<code>Deauthenticaion</code>帧则<strong>退回状态1</strong>。</p>
<p>由于802.11管理帧是没有校验机制的，因此攻击者可以任意伪造这两类帧，达到断开用户连接的目的。连续大量发送这两类帧可以造成拒绝服务；而更多情况下攻击者会利用这一机制短暂的让客户端掉线，以收集认证过程中的数据包（WEP的认证或WPA的四次握手），以便用来破解Wi-Fi密码。</p>
<h3 id="相关工具-2"><a href="#相关工具-2" class="headerlink" title="相关工具"></a>相关工具</h3><p>这部分在Kali中没有独立的工具，都包含在其他的工具集中，如<a href="https://tools.kali.org/wireless-attacks/mdk3">mdk3</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Wi-Fi安全已经不是一个新鲜的话题，甚至已经是一个烂大街的话题了。本文尝试系统的梳理Wi-Fi安全的可能攻击点，以及部分攻击的原理，希望能够在Wi-Fi安全方面有个全局的观念，而不是停留在针对某个点的利用，比如破解你邻居的Wi-Fi密码。</p>
<p>在实际的应用中，这些攻击点可以被组合利用进行各种各样的攻击，而WiFi Pineapple等项目则是很好的集成了这些工具。如果后期有时间，我会尝试结合攻击点来分析这些测试工具。</p>
<p>参考文献</p>
<p>[1] 维基百科编者. Wi-Fi[G/OL]. 维基百科, 2020(20200522)[2020-05-22]. <a href="https://zh.wikipedia.org/w/index.php?title=Wi-Fi&amp;oldid=59764163">https://zh.wikipedia.org/w/index.php?title=Wi-Fi&amp;oldid=59764163</a>.</p>
<p>[2] 维基百科编者. IEEE 802.11[G/OL]. 维基百科, 2020(20200427)[2020-04-27]. <a href="https://zh.wikipedia.org/w/index.php?title=IEEE_802.11&amp;oldid=59378008">https://zh.wikipedia.org/w/index.php?title=IEEE_802.11&amp;oldid=59378008</a>.</p>
]]></content>
      <tags>
        <tag>Wi-Fi</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python搭建长连接中间人工具分析流量</title>
    <url>/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>使用Burpsuite或者Fiddler等工具做HTTP代理分析流量是渗透测试的基操，对于测试Web Application或者API接口效果都很好。但是，Burpsuite无法正确处理HTTP长连接(持久连接)，即头部字段Connection: Alive的情况。</p>
<a id="more"></a>

<p>书继续接上文。在愉快的搭建了反向代理展开一系列测试之后，当我测试某台IoT设备的时候，Burpsuite中收到了一个异形数据包，且设备无法正常联网，开启代理之后过一会儿就显示设备离线。</p>
<p>这个数据包是在设备尝试登录云平台的时候，请求<code>/login</code>时发生的：</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200515161731104.png" alt="image-20200515161731104"></p>
<p>从Response可以看出，这个请求的响应似乎是三个数据包叠在一起了，一个是正常的Response，紧接着是两个连续的POST请求。</p>
<p>但是，在Python的<code>Requests</code>模块在处理Response的时候，会通过头部的<code>Content-Length</code>字段对后面的Body部分进行裁剪，导致Burpsuite部分看到的响应与实际从Python反向代理发出的不一致（实际发出的时候后面两个POST请求直接被删掉了）。</p>
<p>分析到这里，我初步认为是Python在处理异形Response的时候没有带上后续的请求，导致设备无法接收到预期的数据从而无法进行后续的通信。</p>
<h2 id="使用自定义字符串验证"><a href="#使用自定义字符串验证" class="headerlink" title="使用自定义字符串验证"></a>使用自定义字符串验证</h2><p>既然如此，在解决这个问题之前，需要先验证想法是否正确。既然<code>HTTPServer</code>无法处理，且每次回复的内容都是固定的，那先尝试用<strong>自定义的字符串</strong>作为Response来进行回复，绕过<code>HTTPServer</code>的解析（代理部分的完整代码请参见上一篇文章）：</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200518102743490.png" alt="image-20200518102743490"></p>
<p>先用Burpsuite尝试一下，看看回复是否正确：</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200518103302446.png" alt="image-20200518103302446"></p>
<p>与之前抓包的内容一致。</p>
<p>开启设备，本以为可以正常了，结果发现设备端不断的在发送Login请求，而且没有任何后续的请求到达，那么说明设备端并没有认这个回复。</p>
<p>折腾了许久也没想明白到底是怎么回事，毕竟响应包里并没有什么认证信息，暂时排除认证失败导致的设备响应异常，直到无意间用Wireshark抓了一下包之后发现了其中的秘密：</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200518143904406.png" alt="image-20200518143904406"></p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200518143827391.png" alt="image-20200518143827391"></p>
<p>先分析本机的抓包结果，可以很明显的看到一个完整的TCP交互过程，从三次握手开始，然后是协商TLS的密钥，再传输数据，最后四次挥手断开连接。数据传输阶段，也只是有三个<code>Application Data</code>包进行了传输。</p>
<p>而分析路由器上抓包结果，设备端在三次握手建立连接、TLS协商后，有着大量的数据包交互，显然整个流程上与代理部分完全不同。</p>
<h2 id="检查协议头"><a href="#检查协议头" class="headerlink" title="检查协议头"></a>检查协议头</h2><p>再次回头去看请求中的内容，在头部的<code>Connection</code>字段中发现了端倪。回到Burpsuite中那个“异形”数据包。可以看到在Response的部分中，头部的<code>Connection</code>字段的值为<code>Keep-Alive</code>：</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200519095658256.png" alt="image-20200519095658256"></p>
<p>一般情况下，这个值是<code>Close</code>，如访问百度首页的请求中，Request和Response中的值：</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200518145409550.png" alt="image-20200518145409550"></p>
<p>而这个“异形”数据包里的<code>Keep-Alive</code>就显得有点与众不同。</p>
<p>通过度娘初步得知，<code>Connection: Keep-Alive</code>是长连接建立的标志，而在**<a href="https://tools.ietf.org/html/rfc2616">RFC2616</a>**的第8章中对长连接有详细的描述。实际上这种头部定义的连接应该叫做持久连接（Persistent Connection），即建立一次TCP连接后，利用该连接进行多次通信，减少建立TCP连接产生的负载。</p>
<blockquote>8.1.1 Purpose<br>
    Prior to persistent connections, a separate TCP connection was<br>
    established to fetch each URL, increasing the load on HTTP servers<br>
    and causing congestion on the Internet. The use of inline images and<br>
    other associated data often require a client to make multiple<br>
    requests of the same server in a short amount of time.<br>
    <br>
    在持久连接出现之前，每次请求URL时都会建立一个单独的TCP连接，(这种做法)增加了HTTP服务器的负载，并造成Internet的拥塞。<br>
    在使用内联图片及其他相关数据时，客户端需要在短时间内向同一个服务端发起多次请求。

<p>在Wikipedia上，我们常说的“短连接”和“长连接”的示意图如下（可能翻译成“多次连接”和“持久连接”会更贴近原意）：</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7%5C1920px-HTTP_persistent_connection.svg.png"></p>
<p>但是，需要注意的是，虽然是允许在同一个TCP连接中传输多次数据，但模式仍是客户端发起、服务端响应，服务端并不能直接向客户端发送数据。</p>
<h2 id="WebSocket与持久连接"><a href="#WebSocket与持久连接" class="headerlink" title="WebSocket与持久连接"></a>WebSocket与持久连接</h2><p>从路由器抓包的内容，以及文章开头提及的那个“异形”数据包来看，似乎设备与服务端的通信并不是单纯的设备端请求、服务端应答的模式，而更偏向于全双工的形式，即服务端也能向设备端主动发送数据。这里乍看起来很像WebSocket(引用自Wikipedia)：</p>
<blockquote>WebSocket 是独立的、创建在TCP上的协议。<br>
Websocket 通过 HTTP/1.1 协议的101状态码进行握手。<br>
为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（Handshaking）。</blockquote>

<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200518153422059.png" alt="image-20200518153422059"></p>
<p>而实际从代理中看到的那个“异形”数据并没有<code>Upgrade</code>头部，且<code>Connection</code>字段也不是Upgrade，那么并不是标准的WebSocket协议。</p>
<h2 id="编写工具"><a href="#编写工具" class="headerlink" title="编写工具"></a>编写工具</h2><p>经过一系列分析，现在能确定的是：</p>
<ol>
<li>这个设备在与服务器通信的时候使用的是一个TCP连接传输多次数据</li>
<li>设备端并非只进行Response，而是有主动发送数据的能力</li>
<li>协议用的仍是基于HTTP的协议，而不是WebSocket</li>
</ol>
<p>那么我们需要该工具能处理<strong>长连接（持久连接）</strong>，在设备侧和服务器侧均保持连接的状态，且根据双方的情况选择建立或断开连接。即任意一方在断开连接后，工具能正确关闭另一侧的连接（工具处理流量的拓扑图参见上一篇文章中的图）。</p>
<p>作为中间人工具，无需对请求进行处理，如判断URL，判断Method等，只需要单纯的转发即可，因此可以不用HTTP框架，直接用Socket来处理到达的TCP连接并转发。</p>
<p>起初打算用线程的方式来完成对两端的连接管理，一条线程负责监听设备端发送来的数据，并发送给客户端；另一条线程负责监听服务端发送的数据并转发给客户端：</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200518160456346.png" alt="image-20200518160456346"></p>
<p>但是，直接设置线程在管理上会比较麻烦，当客户端主动断开连接时，需要通知另一线程关闭；此时还需要判断当前线程对应的另一线程中的Socket是哪一个，涉及到线程之间交互，要动用队列等，较为麻烦。</p>
<p>使用Python的<code>select.epoll</code>可以进行异步I/O操作，正好适用于当前的场景。epoll是一种异步I/O模型，允许以非阻塞的模式处理I/O，如TCP连接。在代码逻辑上与线程的方式最直观的区别，就是它会等待Socket连接活动，并触发事件，利用epoll提供的FD来表示当前处理的Socket连接是哪一个，对于管理服务端和客户端的连接都非常方便。</p>
<p>核心代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解析到达的HTTP请求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_info</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;\r\n\r\n&#x27;</span> <span class="keyword">in</span> request:</span><br><span class="line">        [req_list, body] = request.split(<span class="string">&#x27;\r\n\r\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        req_list = request</span><br><span class="line">        body = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    req_list = req_list.split(<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> len(req_list) &gt; <span class="number">1</span>:</span><br><span class="line">        info = req_list[<span class="number">0</span>]</span><br><span class="line">        req_list.remove(req_list[<span class="number">0</span>])</span><br><span class="line">        headers = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> req_list:</span><br><span class="line">            header = item.split(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">            headers[header[<span class="number">0</span>]] = header[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;request&quot;</span>: info,</span><br><span class="line">                <span class="string">&quot;headers&quot;</span>: headers,</span><br><span class="line">                <span class="string">&quot;body&quot;</span>: body&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    port = <span class="number">443</span></span><br><span class="line">    context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 载入证书文件</span></span><br><span class="line">    certfile = <span class="string">&#x27;./conf/cert.crt&#x27;</span></span><br><span class="line">    keyfile = <span class="string">&#x27;./conf/cert.key&#x27;</span></span><br><span class="line">    context.load_cert_chain(certfile, keyfile)</span><br><span class="line">    print(<span class="string">&quot;Loading cert files:&quot;</span>, certfile, keyfile)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 建立Socket监听客户端请求</span></span><br><span class="line">    SOCK = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    SOCK.bind((<span class="string">&quot;0.0.0.0&quot;</span>, port))</span><br><span class="line">    SOCK.listen(<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置证书</span></span><br><span class="line">    tcp_server_socket = context.wrap_socket(SOCK, server_side=<span class="literal">True</span>)</span><br><span class="line">    tcp_server_socket.setblocking(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启用epoll</span></span><br><span class="line">    epl = select.epoll()</span><br><span class="line">    epl.register(tcp_server_socket.fileno(), select.EPOLLIN)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 连接池，用来管理连接</span></span><br><span class="line">    fd_event_dict = dict()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 主循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        fd_event_list = epl.poll()</span><br><span class="line">        <span class="keyword">for</span> fd, event <span class="keyword">in</span> fd_event_list:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当新连接到达</span></span><br><span class="line">            <span class="keyword">if</span> fd == tcp_server_socket.fileno():</span><br><span class="line">                <span class="comment"># 建立连接</span></span><br><span class="line">                new_socket, client_addr = tcp_server_socket.accept()</span><br><span class="line">                <span class="comment"># 在epoll中注册</span></span><br><span class="line">                epl.register(new_socket.fileno(), select.EPOLLIN)</span><br><span class="line">                <span class="comment"># 加入连接池</span></span><br><span class="line">                fd_event_dict[new_socket.fileno()] = [new_socket, <span class="literal">None</span>]</span><br><span class="line">            <span class="comment"># 当有数据读入</span></span><br><span class="line">            <span class="keyword">elif</span> event == select.EPOLLIN:</span><br><span class="line">                <span class="comment"># 接收数据（Bytes）</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    recv_data = fd_event_dict[fd][<span class="number">0</span>].recv(<span class="number">4096</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">                    <span class="comment"># 若有数据接收到</span></span><br><span class="line">                    <span class="keyword">if</span> recv_data:</span><br><span class="line">                        <span class="comment"># 判断当前这个fd有没有建立对端</span></span><br><span class="line">                        <span class="comment"># 一般情况下是设备端（客户端）发起连接，此处检查有没有与服务端建立连接</span></span><br><span class="line">                        <span class="keyword">if</span> fd_event_dict[fd][<span class="number">1</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                            <span class="comment"># 解析HTTP请求</span></span><br><span class="line">                            info = get_info(recv_data)</span><br><span class="line">                            <span class="comment"># 读取请求里的Host字段</span></span><br><span class="line">                            host = info[<span class="string">&quot;headers&quot;</span>][<span class="string">&quot;Host&quot;</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">                            <span class="comment"># 建立新连接</span></span><br><span class="line">                            new_socket = ssl.wrap_socket(socket.socket())</span><br><span class="line">                            new_socket.connect((host, port))</span><br><span class="line">                            <span class="comment"># 注册</span></span><br><span class="line">                            epl.register(new_socket.fileno(), select.EPOLLIN)</span><br><span class="line">                            <span class="comment"># 将这个fd写入当前连接的字典中</span></span><br><span class="line">                            fd_event_dict[fd] = (fd_event_dict[fd][<span class="number">0</span>], new_socket.fileno())</span><br><span class="line">                            <span class="comment"># 添加一个新的项</span></span><br><span class="line">                            fd_event_dict[new_socket.fileno()] = (new_socket, fd)</span><br><span class="line">                        <span class="comment"># 如果有建立对端，则直接发送</span></span><br><span class="line">                        <span class="comment"># socket.getpeername(): 返回发送方的IP地址和端口</span></span><br><span class="line">                        peer_fd = fd_event_dict[fd][<span class="number">1</span>]</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment"># 打印信息</span></span><br><span class="line">                        print(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-&quot;</span> * <span class="number">20</span>)</span><br><span class="line">                        print(<span class="string">&quot;From: %s, To: %s, fd: %s&quot;</span> % (fd_event_dict[fd][<span class="number">0</span>].getpeername()[<span class="number">0</span>], fd_event_dict[peer_fd][<span class="number">0</span>].getpeername()[<span class="number">0</span>], fd))</span><br><span class="line">                        print(<span class="string">&quot;\n&quot;</span> + recv_data + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-&quot;</span> * <span class="number">20</span>)</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment"># 发送数据</span></span><br><span class="line">                        fd_event_dict[peer_fd][<span class="number">0</span>].send(recv_data.encode())</span><br><span class="line">                    <span class="comment"># 没有数据则表示连接断开</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 关闭对端socket并反注册</span></span><br><span class="line">                        peer_fd = fd_event_dict[fd][<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> peer_fd:</span><br><span class="line">                            fd_event_dict[peer_fd][<span class="number">0</span>].close()</span><br><span class="line">                            epl.unregister(peer_fd)</span><br><span class="line">                            <span class="keyword">del</span> fd_event_dict[peer_fd]</span><br><span class="line">                        <span class="comment"># 关闭当前socket</span></span><br><span class="line">                        fd_event_dict[fd][<span class="number">0</span>].close()</span><br><span class="line">                        <span class="comment"># 反注册</span></span><br><span class="line">                        epl.unregister(fd)</span><br><span class="line">                        <span class="comment"># 删除记录</span></span><br><span class="line">                        <span class="keyword">del</span> fd_event_dict[fd]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 错误处理</span></span><br><span class="line">                <span class="keyword">except</span> ssl.SSLError <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="comment"># 关闭对端socket并反注册</span></span><br><span class="line">                    peer_fd = fd_event_dict[fd][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> peer_fd:</span><br><span class="line">                        fd_event_dict[peer_fd][<span class="number">0</span>].close()</span><br><span class="line">                        epl.unregister(peer_fd)</span><br><span class="line">                        <span class="keyword">del</span> fd_event_dict[peer_fd]</span><br><span class="line">                    <span class="comment"># 关闭当前socket</span></span><br><span class="line">                    fd_event_dict[fd][<span class="number">0</span>].close()</span><br><span class="line">                    <span class="comment"># 反注册</span></span><br><span class="line">                    epl.unregister(fd)</span><br><span class="line">                    <span class="comment"># 删除记录</span></span><br><span class="line">                    <span class="keyword">del</span> fd_event_dict[fd]</span><br><span class="line">                    print(<span class="string">&quot;SSL Error&quot;</span>, len(fd_event_dict), e)</span><br><span class="line">                <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">                    print(<span class="string">&quot;OS Error&quot;</span>, len(fd_event_dict))</span><br></pre></td></tr></table></figure>

<p>代码质量不是很高，因为也是临时测试用，就没有优化，大神勿喷~</p>
<h2 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h2><p>在实战之前需要指出，epoll仅在Linux系统环境下支持，在Windows下Python会提示<code>AttributeError: module &#39;select&#39; has no attribute &#39;epoll&#39;</code>。解决方法有两个：</p>
<p>一是用虚拟机，缺点是网络上可能不好设置，有些网络状况没法选桥接；二是如果是Windows 10系统，可以通过安装WSL(Windows Linux Subsystem)来解决。WSL在文件和网络接口上与Windows都是共用的，但是可以运行Linux程序，非常好用，安装也比较便捷，随便搜索一下都有一大把教程，安装和使用在此不再赘述。</p>
<p>提示：在Linux环境下操作网络需要管理员权限，因此需要加<code>sudo</code>命令，否则会报错！</p>
<h3 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h3><p>在查看之前，需要先引导流量到本机上，因此需要DNS欺骗。方法仍是利用极路由插件设置，将目标域名的IP设置成本机IP即可。</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200518164513484.png" alt="image-20200518164513484"></p>
<p>这里说明一下，一般来说访问网络连接都会用域名的形式，但如果测试目标头很铁就是要用IP的方式，那么DNS欺骗就没用了（都没解析DNS骗啥！），这时候只能选择ARP攻击，将流量引导到本机，再设置iptables端口转发。</p>
<p><strong>另外一个要说明的地方，如果在路由器上做DNS欺骗，PC和被测目标都会被欺骗（这就是传说中的“连自己都骗”吗），因此需要在PC端手动修改Hosts文件来避免自己被欺骗从而无法正常将数据转发出去。</strong>以上图中的<code>www.bbb.com</code>为例，在本机的hosts文件中添加真实解析：</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200519091131549.png" alt="image-20200519091131549"></p>
<p>此外，如果你使用的是WSL，那么需要在WSL中修改而不是Windows中。</p>
<blockquote>
<p>DNS解析顺序：</p>
<p>本地缓存 &gt; Hosts文件 &gt; 路由器DNS &gt; ISP DNS服务器</p>
</blockquote>
<h3 id="流量监听"><a href="#流量监听" class="headerlink" title="流量监听"></a>流量监听</h3><p>设置好DNS欺骗之后，重启目标设备，此时设备会请求目标域名的DNS，路由器会回复我们设置的值（即本机IP），此时流量是发往PC端的，再由Python进行转发到真实服务器：</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200519092531330.png" alt="image-20200519092531330"></p>
<p>打开工具，等待设备连接（如果设备流量没走工具转发，可以尝试重启设备以清空DNS缓存），即可在控制台看到流量信息：</p>
<p><img src="/2020/05/15/%E5%88%A9%E7%94%A8Python%E6%90%AD%E5%BB%BA%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%B7%A5%E5%85%B7/image-20200519093541545.png" alt="image-20200519093541545"></p>
<p>这里可以明显看到从服务端推送过来的数据，也和之前在Wireshark中查看的内容吻合。</p>
<p>接下来即可在原来的代码基础上，对数据发送的部分进行魔改，来完成篡改、伪造消息的操作。因为这部分代码定制化较高，且写的不完善，在此就不放出了，大家可以各显神通来完成这部分逻辑。</p>
</blockquote>]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MitM</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
</search>
